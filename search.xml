<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Docker容器]]></title>
    <url>%2F2019%2F10%2F13%2FDocker%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[容器是什么简单来说，容器通过利用操作系统的一些底层技术（Namespace、UnionFS、Cgroup等）来运行一些进程。Docker封装了这些底层技术（Container format），方便用户去使用 容器的好处 可移植性/快速部署: 不需要关心不同的运行环境，容器运行所需的库都是打包好的一个整体 应用打包灵活高效: 由于image的分层共享设计，需要更换某一层的内容变得高效灵活 提升资源利用率（相比VM）: 共享底层的操作系统，管理程序没有额外的开销 VM VS Container虚拟机与容器的不同 Docker概述 Image / VolumeDocker容器中的数据管理 Network Default Bridge User Defined Bridge Overlay Network Ingress Network Docker容器间的通信]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker Compose]]></title>
    <url>%2F2019%2F09%2F18%2FDocker-Compose%2F</url>
    <content type="text"><![CDATA[WHATDocker Compose是用Python编写的工具，并不包含在Docker Engine安装包中。Docker Compose用于解析YML文件并运行YML中定义的容器服务。Docker Compose命令通过调用Docker API完成多容器的创建启动，使用Docker Compose需要自行安装 Docker Compose VS Docker Stack docker stack 包含在 swarm mode中，swarm mode 已经被集成到Docker Engine中，由GO语言编写。docker compose 需要自行安装，由Python编写 docker stack 只支持 version &gt;= 3 的YML定义且部分命令无法生效如 build。docker compose 对YML的不同version处理都没有问题 docker stack 可以将服务分发到不同的主机上，docker compose 只能将服务分发到同一台主机上 WHY为什么要使用Docker Compose ? 服务发布以下是需要容器化的服务 product-service 商品服务 shopping-service 商店服务，两套界面 redis-service 数据缓存 front-balance 商店服务负载 123456789101112BEFORE COMPOSE :docker run -itd --name redis-service --network=backend -p 16379:6379 redisdocker run -itd --name product-service --network=backend -p 15000:5000 8lovelife/product:latestdocker network connect frontend product-servicedocker run -itd --name shopping-service-blue --network=frontend -p 28080:80 8lovelife/shopping:bluedocker run -itd --name shopping-service-red --network=frontend -p 18080:80 8lovelife/shopping:reddocker run -itd --name front-balance --network=frontend -p 80:80 8lovelife/frontbalance:latestAFTER COMPOSE :docker-compose -f docker-compose-product.yml up -d HOW如何使用Docker Compose ? 服务拆分1234567891011121314151617181920212223242526272829303132333435SHOPPING Dockerfile:FROM node:11.1.0-alpine as buildWORKDIR /appCOPY package*.json /app/RUN npm installCOPY ./ /app/RUN npm run buildFROM nginx:1.17.3-alpineCOPY --from=build /app/build /usr/share/nginx/htmlCOPY --from=build /app/nginx.conf /etc/nginx/nginx.confEXPOSE 80CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]PRODUCT Dockerfile:FROM maven:3-jdk-8 as buildRUN mkdir -p /buildWORKDIR /buildCOPY pom.xml /buildRUN mvn -B dependency:resolve dependency:resolve-pluginsCOPY src /build/srcRUN mvn package -Dmaven.test.skip=trueFROM openjdk:8-jdk-alpine as runtimeEXPOSE 5000ENV APP_HOME /appRUN mkdir $APP_HOMEWORKDIR $APP_HOMECOPY --from=build /build/target/*.jar app.jarENTRYPOINT [ &quot;sh&quot;, &quot;-c&quot;, &quot;java $JAVA_OPTS -Djava.security.egd=file:/dev/./urandom -jar app.jar&quot; ]。。。 YML定义本文事例使用的docker-compose-product.yml文件内容如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051version: &quot;3&quot;services: product-service: image: &quot;8lovelife/product:latest&quot; ports: - &quot;15000:5000&quot; networks: - frontend - backend environment: - REDIS_HOST=redis-service - REDIS_PORT=6379 shopping-service-red: image: &quot;8lovelife/shopping:red&quot; ports: - &quot;18080:80&quot; networks: - frontend shopping-service-blue: image: &quot;8lovelife/shopping:blue&quot; ports: - &quot;28080:80&quot; networks: - frontend redis-service: image: &quot;8lovelife/redis:products&quot; ports: - &quot;16379:6379&quot; volumes: - redis_data:/data networks: - &quot;backend&quot; front-balance: image: &quot;8lovelife/frontbalance:latest&quot; ports: - &quot;80:80&quot; networks: - &quot;frontend&quot;networks: frontend: &#123;&#125; backend: &#123;&#125;volumes: redis_data: &#123;&#125; 构建或拉取镜像1234567891011121314# 绝对路径build: .# 相对路径build: ../path/to/app/# Git仓库build: https://url.git# 指定分支的Git仓库 build: https://url.git#develop# 含access_token的Git仓库链接build: https://&lt;ACCESS_TOKEN&gt;:@github.com/demo.git 配置环境变量12345product-service: image: &quot;8lovelife/product:latest&quot; environment: - REDIS_HOST=redis-service - REDIS_PORT=6379 配置网络1234567891011product-service: image: &quot;8lovelife/product:latest&quot; ports: - &quot;15000:5000&quot; networks: - frontend - backend networks: frontend: &#123;&#125; backend: &#123;&#125; 配置数据卷1234567891011redis-service: image: &quot;redis:latest&quot; ports: - &quot;16379:6379&quot; volumes: - redis_data:/data networks: - &quot;backend&quot; volumes: redis_data: &#123;&#125; 构建运行123docker-compose -f docker-compose-product.yml up -ddocker-compose --help compose命令帮助]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring中的@Retryable]]></title>
    <url>%2F2019%2F07%2F25%2FSpring%E4%B8%AD%E7%9A%84-Retryable%2F</url>
    <content type="text"><![CDATA[WHAT@Retryable由spring-retry模块提供，在方法或类上添加@Retryable注解可以实现方法调用失败的重试。可以指定失败重试的次数、fallback方法 @Retryable设置重试的次数、指定需要重试的异常123456789101112131415161718@Target(&#123; ElementType.METHOD, ElementType.TYPE &#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Retryable &#123; // 指定拦截方法 String interceptor() default &quot;&quot;; // 指定需要重试异常，若未指定异常则重试异常为 Exception.class Class&lt;? extends Throwable&gt;[] value() default &#123;&#125;; // 最大尝试次数（包含第一次 int maxAttempts() default 3; Class&lt;? extends Throwable&gt;[] include() default &#123;&#125;; Class&lt;? extends Throwable&gt;[] exclude() default &#123;&#125;; String label() default &quot;&quot;; boolean stateful() default false; String maxAttemptsExpression() default &quot;&quot;; Backoff backoff() default @Backoff(); String exceptionExpression() default &quot;&quot;;&#125; @Backoff设置重试的时间间隔，不同值的组合会确定不同的计算间隔方式123456789101112131415@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Import(RetryConfiguration.class)@Documentedpublic @interface Backoff &#123; long value() default 1000; // 若delay=0未配置，则delay=value long delay() default 0; long maxDelay() default 0; double multiplier() default 0; String delayExpression() default &quot;&quot;; String maxDelayExpression() default &quot;&quot;; String multiplierExpression() default &quot;&quot;; boolean random() default false;&#125; @Recover重试失败后会进入@Recover注解的方法 WHY在项目中假设调用的外部服务发生网络异常、服务器故障、死机状况，在这些情况下通常会重试几次调用，假如最终还是失败则会返回特定的内容。如果可能在后续的尝试中会成功，则有重试的必要。你可能会写一段循环代码然后计数来实现重试功能，@Retryable提供了更便捷的方式来实现错误重试 123456789101112131415BEFORE: int retries = 0; long wait = 1; while (retries &lt; maxRetries) &#123; TimeUnit.SECONDS.sleep(wait); // 处理任务 wait *= 2; ++retries; &#125; AFTER: @Retryable(maxAttempts = 3, backoff = @Backoff(delay = 1000,multiplier = 1.5,maxDelay = 3000)) String retryForError(); @Recover String recoverResponse(Exception e); HOW@Retryable如何使用？怎么实现的？ Requirements12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.retry&lt;/groupId&gt; &lt;artifactId&gt;spring-retry&lt;/artifactId&gt; &lt;version&gt;$&#123;version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;version&#125;&lt;/version&gt;&lt;/dependency&gt; 事例1234567891011121314151617181920212223242526272829303132333435363738public interface RetryService &#123; @Retryable(maxAttempts = 3, backoff = @Backoff(delay = 1000,multiplier = 1.5,maxDelay = 3000), value = ArithmeticException.class) String retryForError(); @Recover String recoverResponse(ArithmeticException e);&#125;public class RetryServiceImpl implements RetryService &#123; @Override public String retryForError() &#123; System.out.println(&quot;retryForError&quot;); int a = 10 / 0; return &quot;Success&quot;; &#125; @Override public String recoverResponse(ArithmeticException e) &#123; return &quot;RecoverResponse Success&quot;; &#125;&#125;@RestControllerpublic class RetryController &#123; @Resource private RetryService retryService; @GetMapping(&quot;/retry&quot;) public String retryService() &#123; return retryService.retryForError(); &#125;&#125; 原理AOP RetryConfiguration 创建pointcut（Retryable注解）, 创建Advice（AnnotationAwareRetryOperationsInterceptor） AnnotationAwareRetryOperationsInterceptor 委托给默认的 RetryOperationsInterceptor BackOffPolicy@Backoff multiplier &gt; 0 and random = false 12345678910111213141516initialInterval = delaymaxInterval = maxDelay &gt; initialInterval ? maxDelay : ExponentialBackOffPolicy.DEFAULT_MAX_INTERVAL(30000毫秒) public synchronized long getSleepAndIncrement() &#123; long sleep = this.interval; if (sleep &gt; maxInterval) &#123; sleep = maxInterval; &#125; else &#123; this.interval = getNextInterval(); &#125; return sleep; &#125; protected long getNextInterval() &#123; return (long) (this.interval * this.multiplier); &#125; multiplier &gt; 0 and random = true 123456public synchronized long getSleepAndIncrement() &#123; // 1 中方法 long next = super.getSleepAndIncrement(); next = (long) (next * (1 + r.nextFloat() * (getMultiplier() - 1))); return next;&#125; maxDelay &gt; initialInterval 12long delta = maxDelay==initialInterval ? 0 : random.nextInt((int) (maxDelay - minBackOffPeriod));sleeper.sleep(minBackOffPeriod + delta ); 其他 1sleeper.sleep(delay); 注意点 @Recover只对同类中的@Retryable生效 多个@Recover方法，同一种异常参数。相当于讲这些方法（Method）放在Set中，取出的第一个@Recover方法将会是fallback方法 多个@Recover方法，不同种异常参数。若@Recover方法参数距离@Retryable方法抛出的异常最近（根据重试的最后一次抛出的异常作为查找依据）则此@Recover方法将会是fallback方法。1RecoverAnnotationRecoveryHandler.findClosestMatch]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring中的@Async]]></title>
    <url>%2F2019%2F05%2F28%2FSpring%E4%B8%AD%E7%9A%84-Async%2F</url>
    <content type="text"><![CDATA[WHAT@Async由Spring定义，在方法上添加此注解，方法的执行将会是异步的(在另一个线程中执行)，调用者不需要等待方法执行完成1234567@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Async &#123; // 用于指定异步执行的线程池名称 String value() default &quot;&quot;;&#125; WHY被@Async标记的方法都可以异步执行，注解的方式非常灵活，异步的线程资源可以集中管理 异步执行 BEFORE123456789101112131415public void sayWorld() &#123; new Thread(() -&gt; &#123; try &#123; TimeUnit.SECONDS.sleep(30); System.out.println(&quot;world&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;).start(); &#125;public void sayHello() &#123; sayWorld(); System.out.println(&quot;hello&quot;);&#125; 异步执行 AFTER12345678910@Asyncpublic void sayWorld() throws InterruptedException &#123; TimeUnit.SECONDS.sleep(30); System.out.println(&quot;world&quot;);&#125;public void sayHello() &#123; sayWorld(); System.out.println(&quot;hello&quot;);&#125; HOW@Async如何使用？又是怎么运作的？ 事例1234567891011121314151617181920212223242526272829303132333435363738394041424344@Configuration@EnableAsyncpublic class AsyncConfigDemo implements AsyncConfigurer &#123; // 优先级低，相对于 @Async指定异步线程池 @Override public Executor getAsyncExecutor() &#123; ThreadPoolTaskExecutor threadPoolTaskExecutor = new ThreadPoolTaskExecutor(); threadPoolTaskExecutor.setCorePoolSize(10); threadPoolTaskExecutor.setThreadNamePrefix(&quot;async-&quot;); threadPoolTaskExecutor.initialize(); return threadPoolTaskExecutor; &#125; @Override public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() &#123; return new SimpleAsyncUncaughtExceptionHandler(); &#125;&#125;@Servicepublic class AsyncDemo &#123; @Async(value = &quot;taskScheduler&quot;) // 优先级高 public void sayWorld() throws InterruptedException &#123; TimeUnit.SECONDS.sleep(3); System.out.println(&quot;world&quot;); &#125;&#125;// 使用 @Resource private AsyncDemo asyncDemo; @Test public void testSync() throws IOException &#123; try &#123; asyncDemo.sayWorld(); System.out.println(&quot;hello&quot;); System.in.read(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; 原理 AsyncConfigDemo由ConfigurationClassParser进行解析，包括注解@EnableAsync上的AsyncConfigurationSelector类 AsyncConfigurationSelector根据@EnableAsync mode()选择代理方式实现，默认为ProxyAsyncConfiguration Configuration类ProxyAsyncConfiguration被创建并注入AsyncConfigurer扩展的executor、exceptionHandler，创建AsyncAnnotationBeanPostProcessor并通过setBeanFactory方法创建AsyncAnnotationAdvisor AsyncAnnotationAdvisor设置advice(AnnotationAsyncExecutionInterceptor，设置缺省获取线程池方法getDefaultExecutor，当未扩展AsyncConfigurer的实现则在执行异步的时候getDefaultExecutor会从Spring的上下文中查找TaskExecutor的实现类实例)。设置pointcut(@Async的注解类或方法或是自定义的异步注解) AnnotationAsyncExecutionInterceptor通过determineAsyncExecutor方法确认执行的Executor。getExecutorQualifier方法查找名为@Async指定的value值的Executor，若找到则执行，若无法确认Executor则调用getDefaultExecutor方法查询类型为TaskExecutor的类，若有多个实现则会查找名字为”taskExecutor”的实现Bean，最终都没有找到则创建SimpleAsyncTaskExecutor(每一个异步的方法任务都会创建一个新的线程)]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring中的@Scheduled]]></title>
    <url>%2F2019%2F05%2F16%2FSpring%E4%B8%AD%E7%9A%84-Scheduled%2F</url>
    <content type="text"><![CDATA[WHAT@Scheduled 由Spring定义，用于将方法设置为调度任务。如：方法每隔十秒钟被执行、方法在固定时间点被执行等 @Scheduled(fixedDelay = 1000)上一个任务结束到下一个任务开始的时间间隔为固定的1秒，任务的执行总是要先等到上一个任务的执行结束 @Scheduled(fixedRate = 1000)每间隔1秒钟就会执行任务（如果任务执行的时间超过1秒，则下一个任务在上一个任务结束之后立即执行） @Scheduled(fixedDelay = 1000, initialDelay = 2000)第一次执行的任务将会延迟2秒钟后才会启动 @Scheduled(cron = “0 15 10 15 * ?”)Cron表达式，每个月的15号上午10点15开始执行任务 在配置文件中配置任务调度的参数 @Scheduled(fixedDelayString = “${fixedDelay.in.milliseconds}”)@Scheduled(fixedRateString = “${fixedRate.in.milliseconds}”)@Scheduled(cron = “${cron.expression}”) WHY@Scheduled使用方便，不需要自己去写复杂的任务调度。注解的方式非常灵活，只需要在方法上添加@Scheduled注解就能定义调度的任务，任何无参的方法都可以瞬间成为供调度的任务 12345678910111213141516171819202122232425/** * 关闭线程池中超过空闲时间的线程 * @param poolingConnectionManager * @return */@Beanpublic Runnable idleConnectionMonitor(final PoolingHttpClientConnectionManager poolingConnectionManager) &#123; return new Runnable() &#123; @Override @Scheduled(fixedDelay = 10000, initialDelay = 1000) public void run() &#123; try &#123; if (poolingConnectionManager != null) &#123; log.info(&quot;run IdleConnectionMonitor - Closing expired and idle connections...&quot;); poolingConnectionManager.closeExpiredConnections(); poolingConnectionManager.closeIdleConnections(properties.getCloseIdleConnectionWaitTimeSecs(), TimeUnit.SECONDS); &#125; else &#123; log.info(&quot;run IdleConnectionMonitor - Http Client Connection manager is not initialised&quot;); &#125; &#125; catch (Exception e) &#123; log.error(&quot;run IdleConnectionMonitor - Exception occurred. msg=&#123;&#125;, e=&#123;&#125;&quot;, e.getMessage(), e); &#125; &#125; &#125;;&#125; HOWSpring是如何实现如此简洁的任务调度定义的？怎么使用@Scheduled？ Requirements Spring容器中需要创建 Bean: ScheduledAnnotationBeanPostProcessor Spring容器中需要有TaskScheduler实现类的实例 无参方法添加@Scheduled注解 扩展扩展有两种方式 实现SchedulingConfigurer接口 123456789101112131415161718 // 优先级高 @Configuration public class SchedulerConfig implements SchedulingConfigurer &#123; @Override public void configureTasks(ScheduledTaskRegistrar taskRegistrar) &#123; taskRegistrar.setTaskScheduler(threadPoolTaskScheduler()); &#125; @Bean(destroyMethod = &quot;shutdown&quot;) public ThreadPoolTaskScheduler threadPoolTaskScheduler() &#123; ThreadPoolTaskScheduler scheduler = new ThreadPoolTaskScheduler(); scheduler.setThreadNamePrefix(&quot;poolmary&amp;mark&quot;); scheduler.setPoolSize(50); return scheduler; &#125;&#125; 创建TaskScheduler的实现Bean 12345678// 相对实现SchedulingConfigurer接口的方式，优先级低@Beanpublic TaskScheduler taskScheduler() &#123; ThreadPoolTaskScheduler scheduler = new ThreadPoolTaskScheduler(); scheduler.setThreadNamePrefix(&quot;poolScheduler&quot;); scheduler.setPoolSize(50); return scheduler;&#125; 原理 ScheduledAnnotationBeanPostProcessor的postProcessAfterInitialization方法将@Scheduled的方法包装为指定的task添加到ScheduledTaskRegistrar中 ScheduledAnnotationBeanPostProcessor会监听Spring的容器初始化事件，在Spring容器初始化完成后进行TaskScheduler实现类实例的查找，若发现有SchedulingConfigurer的实现类实例，则跳过3 查找TaskScheduler的实现类实例默认是通过类型查找，若有多个实现则会查找名字为”taskScheduler”的实现Bean，若没有找到则在 ScheduledTaskRegistrar调度任务的时候会创建一个newSingleThreadScheduledExecutor，将TaskScheduler的实现类实例设置到ScheduledTaskRegistrar属性中 ScheduledTaskRegistrar的scheduleTasks方法触发任务调度 真正调度任务的类是TaskScheduler实现类中的ScheduledExecutorService，由J.U.C提供 事例123456789101112131415161718192021@Configuration@EnableSchedulingpublic class SchedulerConfigDemo &#123; private final static SimpleDateFormat sdf = new SimpleDateFormat(&quot;hh:mm:ss&quot;); private final static Logger log = LoggerFactory.getLogger(SchedulerConfigDemo.class); @Scheduled(fixedRate = 2000, initialDelay = 1000) public void testScheduler() &#123; log.info(&quot;start &#123;&#125;&quot;, sdf.format(new Date())); &#125; @Bean public TaskScheduler taskScheduler() &#123; ThreadPoolTaskScheduler scheduler = new ThreadPoolTaskScheduler(); scheduler.setThreadNamePrefix(&quot;poolScheduler&quot;); scheduler.setPoolSize(10); return scheduler; &#125;&#125;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bean Validation]]></title>
    <url>%2F2019%2F04%2F27%2FBean-Validation%2F</url>
    <content type="text"><![CDATA[WHATBean Validation 是一个java规范。可以通过注解的方式约束定义的对象模型或约束方法的入参和出参对象 Bean Validation 1.0Bean Validation 1.0（JSR303）是最早的一版java标准对象验证规范，是Java EE 6的一部分。认证的具体实现有： 名称 版本 Hibernate Validator 4.3.1.Final Apache BVal 0.5 Bean Validation 1.1Bean Validation 1.1（JSR349）是Java EE 7的一部分。认证的具体实现有： 名称 版本 Hibernate Validator 4.3.1.Final Apache BVal 1.1.2 较JSR303新增 方法级别上的约束，包括入参、出参 DI and CDI（JSR346） 集成 支持组转换 违反约束消息支持EL表达式(JSR341) 集成其他规范，如验证 JAX-RS: Java API for RESTful Web Services more details Bean Validation 2.0Bean Validation 2.0（JSR380）是Java EE 8的一部分。认证的具体实现有： 名称 版本 Hibernate Validator 6.0.1.Final 较JSR380新增 可针对容器中的元素进行约束 支持data/time 的@Past、@Future约束 新的内置约束注解，如：@Email, @NotEmpty, @NotBlank, @Positive, @PositiveOrZero, @Negative, @NegativeOrZero, @PastOrPresent and @FutureOrPresent 可以通过反射取得字段值（field的注解约束不需要实现getter方法也可以进行约束校验，1.0和1.1必须实现getter方法） more details WHY为什么要使用Bean Validation ?验证参数 BEFORE12345678910Book book = new Book();if (book != null &amp;&amp; book.getCategory() != null &amp;&amp; book.getCategory().trim().length() != 0 &amp;&amp; book.getTitle() != null &amp;&amp; book.getTitle().trim().length() != 0 &amp;&amp; book.getWriter() != null &amp;&amp; book.getWriter().trim().length() != 0) &#123; // TODO&#125; 验证参数 AFTER12345678910111213public class Book &#123; @NotBlank private String title; @NotBlank private String writer; @NotBlank private String category; // setter/getter &#125; validator.validate(new Book()) 减少频繁、冗余的if判断 Constrain once，validate everywhere HOWBean Validation 怎么用？ Requirements（选择 Hibernate Validator实现）123456789101112MAVEN依赖： &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;6.0.1.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish&lt;/groupId&gt; &lt;artifactId&gt;javax.el&lt;/artifactId&gt; &lt;version&gt;3.0.1-b06&lt;/version&gt; &lt;/dependency&gt; 约束常用的注解约束解释 基本约束123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123public class BeanForValidate &#123; /** * 元素： CharSequence * 约束：不能为null, 至少包含一个非空字符 */ @NotBlank private String blankStr = &quot; &quot;; /** * 元素：CharSequence(length)、Collection(size)、Map(size)、Array(length) * 约束：不能为null, 不能为空 */ @NotEmpty private String emptyStr = &quot; &quot;; @NotEmpty private List&lt;Integer&gt; emptyList; /** * 元素：BigDecimal、BigInteger、byte、short、int、long（包括原型的包装类） * 约束：min &lt;= element &lt;=max , null 合法 */ @Min(value = 11) @Max(value = 21) // 11&lt;=size&lt;=21 private Integer minMaxInt = 10; @Min(value = 21) private BigDecimal minDecimal = new BigDecimal(&quot;20.9&quot;); /** * 元素：BigDecimal、BigInteger、CharSequence、byte、short、int、long（包括原型的包装类） * 约束：element &gt;= DecimalMin, null 合法 */ @DecimalMin(value = &quot;100.2&quot;) private String decimalMinDecimal = &quot;100.1&quot;; /** * 元素：CharSequence(length)、Collection(size)、Map(size)、Array(length) * 约束：size(min) &lt;= element &gt;= size(max)，null 合法 */ @Size(min = 1, max = 3) // 1&lt;=size&lt;=3 private String sizeStr = &quot;size&quot;; @Size(min = 1) @NotNull private List&lt;String&gt; nullSizeList = new ArrayList&lt;&gt;(); &#123; nullSizeList.add(&quot;A&quot;); nullSizeList.add(&quot;B&quot;); &#125; /** * 元素：BigDecimal、BigInteger、byte、short、int、long、float、double（包括原型的包装类） * 约束：必须是正数, 0非法 ,null 合法 */ @Positive private Integer positive = -1; /** * 元素：BigDecimal、BigInteger、CharSequence、byte、short、int、long（包括原型的包装类） * 约束：element整数位数=integer , element小数位数=fraction ，null 合法 */ @Digits(integer = 3, fraction = 2) // 只允许在3位整数和2位小数范围内 private String digits = &quot;99.212&quot;; /** * 元素：Date、Calendar、Instant、LocalDate、LocalDateTime、LocalTime、MonthDay、OffsetDateTime、 * OffsetTime、Year、YearMonth、ZonedDateTime、HijrahDate、JapaneseDate、MinguoDate、ThaiBuddhistDate * 约束：时间是在未来，当前时间默认的是 JVM的时间，null 合法 */ @Future private Date passTime; &#123; Calendar instance = Calendar.getInstance(); instance.add(Calendar.DAY_OF_YEAR, -1); passTime = instance.getTime(); &#125; /** * 元素：CharSequence * 约束：是否符合正则表达式，null 合法 */ @Pattern(message = &quot;身份证账号格式错误&quot;, regexp = &quot;(^[1-9]\\d&#123;5&#125;(18|19|([23]\\d))\\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\\d&#123;3&#125;[0-9Xx]$)|(^[1-9]\\d&#123;5&#125;\\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\\d&#123;3&#125;$)/&quot;) // 身份证号验证 private String idCard = &quot;92002199902137720&quot;; @Email @NotBlank private String mail = &quot;12.12@com.com&quot;;&#125;校验： BeanForValidate beanForValidate = new BeanForValidate(); Validator validator = Validation.buildDefaultValidatorFactory().getValidator(); Set&lt;ConstraintViolation&lt;BeanForValidate&gt;&gt; result = validator.validate(beanForValidate); List&lt;String&gt; message = result.stream().map(v -&gt; v.getPropertyPath() + &quot; &quot; + v.getMessage() + &quot;: &quot; + v.getInvalidValue()) .collect(Collectors.toList()); 结果：positive must be greater than 0: -1minMaxInt 最小不能小于11: 10minDecimal 最小不能小于21: 20.9decimalMinDecimal 必须大于或等于100.2: 100.1idCard 身份证账号格式错误: 92002199902137720sizeStr 个数必须在1和3之间: sizeemptyList 不能为空: nullpassTime 需要是一个将来的时间: Fri Apr 19 18:06:18 CST 2019blankStr 不能为空: digits 数字的值超出了允许范围(只允许在3位整数和2位小数范围内): 999.212 嵌套约束1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class BeanGraphForValidate &#123; @NotEmpty private List&lt;@Valid BeanForValidate&gt; beanForValidates; // Bean Validation 2.0// OR// @NotEmpty// @Valid 嵌套校验需要指定 @Valid注解// private List&lt;BeanForValidate&gt; beanForValidatess; @NotEmpty private Map&lt;String, @Valid BeanForValidate&gt; beanForValidateMap; // Bean Validation 2.0// OR// @NotEmpty// @Valid// private Map&lt;String,BeanForValidate&gt; beanForValidateMapM; &#123; beanForValidates = new ArrayList&lt;&gt;(); BeanForValidate beanForValidate = new BeanForValidate(); beanForValidates.add(beanForValidate); beanForValidateMap = new HashMap&lt;&gt;(); beanForValidateMap.put(&quot;map&quot;, beanForValidate); &#125;&#125;校验： ValidatorFactory validatorFactory = Validation.byProvider(HibernateValidator.class) .configure().failFast(false).buildValidatorFactory(); Validator validator = validatorFactory.getValidator(); BeanGraphForValidate beanGraphForValidate = new BeanGraphForValidate(); Set&lt;ConstraintViolation&lt;BeanGraphForValidate&gt;&gt; result = validator.validate(beanGraphForValidate); List&lt;String&gt; message = result.stream().map(v -&gt; v.getPropertyPath() + &quot; &quot; + v.getMessage() + &quot;: &quot; + v.getInvalidValue()) .collect(Collectors.toList()); for (String str : message) &#123; System.out.println(str); &#125; 结果：beanForValidateMap[map].emptyList 不能为空: nullbeanForValidates[0].sizeStr validated size size: sizebeanForValidateMap[map].blankStr 不能为空: beanForValidateMap[map].property 不能为空: nullbeanForValidateMap[map].passTime 需要是一个将来的时间: Mon Apr 22 00:44:45 CST 2019beanForValidates[0].minDecimal the element is 20.9, but need element &lt; 21: 20.9beanForValidateMap[map].minMaxInt 最小不能小于11: 10beanForValidates[0].decimalMinDecimal 必须大于或等于100.2: 100.1beanForValidateMap[map].idCard 身份证账号格式错误: 92002199902137720beanForValidates[0].positive must be greater than 0: -1beanForValidateMap[map].digits 数字的值超出了允许范围(只允许在3位整数和2位小数范围内): 99.212beanForValidates[0].minMaxInt 最小不能小于11: 10beanForValidateMap[map].minDecimal the element is 20.9, but need element &lt; 21: 20.9beanForValidates[0].idCard 身份证账号格式错误: 92002199902137720beanForValidates[0].property 不能为空: nullbeanForValidates[0].passTime 需要是一个将来的时间: Mon Apr 22 00:44:45 CST 2019beanForValidateMap[map].sizeStr validated size size: sizebeanForValidates[0].blankStr 不能为空: beanForValidates[0].digits 数字的值超出了允许范围(只允许在3位整数和2位小数范围内): 99.212beanForValidateMap[map].positive must be greater than 0: -1beanForValidateMap[map].decimalMinDecimal 必须大于或等于100.2: 100.1beanForValidates[0].emptyList 不能为空: null 分组约束1234567891011121314151617181920212223242526272829303132public class BeanForGroupValidate &#123; interface ListGroup &#123; &#125; interface MapGroup &#123; &#125; @NotNull(groups = ListGroup.class, message = &quot;listGroup&quot;) // 用于指定需要校验的组 private List&lt;String&gt; list; @NotNull(groups = MapGroup.class, message = &quot;mapGroup&quot;) private Map&lt;String, String&gt; map; @NotNull(message = &quot;belong defaultGroup&quot;) // 未指明分组则为缺省组 Default.class private Map&lt;String, String&gt; defaultMap;&#125;校验：validator.validate(beanGraphForValidate)结果：defaultMap belong to defaultGroup: null校验：validator.validate(beanGraphForValidate, BeanForGroupValidate.ListGroup.class)结果：list listGroup: null校验：validator.validate(beanGraphForValidate, BeanForGroupValidate.MapGroup.class)结果：map mapGroup: null 方法参数约束 入参 出参 构造器参数 构造器返回123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596public class MethodValidate &#123; @NotBlank private String name; @NotNull private Integer age; @NotNull public MethodValidate(String name) &#123; this.name = name; &#125; public MethodValidate(@NotNull Integer age) &#123; this.age = age; &#125; @Size(min = 2, max = 2) public List&lt;String&gt; getPeopleName() &#123; List&lt;String&gt; peoples = new ArrayList&lt;&gt;(); peoples.add(name); return peoples; &#125; public void setPeopleName(@NotBlank String name) &#123; this.name = name; &#125;&#125;校验：ValidatorFactory factory = Validation.buildDefaultValidatorFactory(); ExecutableValidator executableValidator = factory.getValidator().forExecutables(); MethodValidate methodValidate = new MethodValidate(&quot;Mary&quot;); Method method = MethodValidate.class.getMethod( &quot;setPeopleName&quot;, String.class ); Object[] parameterValues = &#123; &quot;&quot; &#125;; Set&lt;ConstraintViolation&lt;MethodValidate&gt;&gt; validateSetPeopleName = executableValidator.validateParameters( methodValidate, method, parameterValues ); List&lt;String&gt; messages = validateSetPeopleName.stream().map(v -&gt; v.getPropertyPath() + &quot; &quot; + v.getMessage() + &quot;: &quot; + v.getInvalidValue()) .collect(Collectors.toList()); System.out.println(messages); method = MethodValidate.class.getMethod(&quot;getPeopleName&quot;); List&lt;String&gt; peoples = new ArrayList&lt;&gt;(); peoples.add(&quot;Mary&quot;); Set&lt;ConstraintViolation&lt;MethodValidate&gt;&gt; validateGetPeopleName = executableValidator.validateReturnValue( methodValidate, method, peoples ); messages = validateGetPeopleName.stream().map(v -&gt; v.getPropertyPath() + &quot; &quot; + v.getMessage() + &quot;: &quot; + v.getInvalidValue()) .collect(Collectors.toList()); System.out.println(messages); Constructor&lt;MethodValidate&gt; constructorParams = MethodValidate.class.getConstructor(Integer.class); Object[] params = &#123;null&#125;; Set&lt;ConstraintViolation&lt;MethodValidate&gt;&gt; validateConstructor = executableValidator.validateConstructorParameters( constructorParams, params ); messages = validateConstructor.stream().map(v -&gt; v.getPropertyPath() + &quot; &quot; + v.getMessage() + &quot;: &quot; + v.getInvalidValue()) .collect(Collectors.toList()); System.out.println(messages); Constructor&lt;MethodValidate&gt; constructorReturn = MethodValidate.class.getConstructor(String.class); MethodValidate createdBean = new MethodValidate(18); Set&lt;ConstraintViolation&lt;MethodValidate&gt;&gt; validateConstructorReturn = executableValidator.validateConstructorReturnValue( constructorReturn, createdBean ); messages = validateConstructorReturn.stream().map(v -&gt; v.getPropertyPath() + &quot; &quot; + v.getMessage() + &quot;: &quot; + v.getInvalidValue()) .collect(Collectors.toList()); System.out.println(messages); 结果：[setPeopleName.arg0 不能为空: ][getPeopleName.&lt;return value&gt; 个数必须在2和2之间: [Mary]][MethodValidate.arg0 不能为null: null][] 集成如何将Bean Validation集成到Spring MVC框架中？ Requirements123456789101112MAVEN依赖： &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;6.0.1.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish&lt;/groupId&gt; &lt;artifactId&gt;javax.el&lt;/artifactId&gt; &lt;version&gt;3.0.1-b06&lt;/version&gt; &lt;/dependency&gt; 扩展123456789@Configurationpublic class WebMvcConfiguration implements WebMvcConfigurer &#123; @Bean public Validator validator() &#123; ValidatorFactory vf = Validation.byProvider(HibernateValidator.class) .configure().failFast(true) .buildValidatorFactory(); return vf.getValidator(); &#125; Controller方法参数校验 RequirementsSpring 容器中需要创建Bean：LocalValidatorFactoryBean，LocalValidatorFactoryBean包含Bean Validation的实现类（通过SPI加载Bean Validation的实现，本文使用hibernate-validator实现） 使用 123456 @RequestMapping(value = &quot;/beanValidation&quot;, method = RequestMethod.POST) public void testBeanValidation(@Valid BeanForValidate beanForValidate) // 分组 @RequestMapping(value = &quot;/beanValidation&quot;, method = RequestMethod.POST) public void testBeanValidation(@Validated(value = Default.class) BeanForValidate beanForValidate) 原理 SpringMVC在创建RequestMappingHandlerAdapter时会将OptionalValidatorFactoryBean设置到WebBindingInitializer属性中，RequestResponseBodyMethodProcessor在解析参数的时候通过WebBindingInitializer将OptionalValidatorFactoryBean绑定到WebDataBinder中，WebDataBinder通过判断参数是否含有@Valid或@Validated来决定是否进行参数校验 异常MethodArgumentNotValidException 校验任意方法 RequirementsSpring 容器中需要创建Bean：MethodValidationPostProcessor 使用 123456789@Validatedpublic interface BeanValidationService &#123; void testBeanValidation(@Valid BeanForValidate beanForValidate); // 分组@Validatedpublic interface BeanValidationService &#123; @Validated(value = Default.class) void testBeanValidation(@Valid BeanForValidate beanForValidate); 原理MethodValidationPostProcessor会对含有@Validated的类或接口做AOP增强 异常ConstraintViolationException @Valid VS @Validated @Valid由validation-api定义，主要用于Bean的嵌套验证使用，也可用于判断Controller方法中的参数是否需要Bean Validation Validated由Spring定义，用于判断Controller方法中的参数是否需要Bean Validation以及用于开启Bean Validation的方法增强的标志。@Validated能够指定validation groups]]></content>
      <categories>
        <category>JSR</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>JSR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Docker搭建监控系统]]></title>
    <url>%2F2019%2F01%2F30%2F%E5%9F%BA%E4%BA%8EDocker%E6%90%AD%E5%BB%BA%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[记录如何基于Docker搭建监控系统 StatsDStatsD 用于统计和聚合系统的指标数据 StatsD client拥有多语言实现，用于将数据发送到StatsD Server StatsD daemon监听StatsD client 发送的数据并整合数据发送(默认每10s)到后端 监控后端 Graphite、influxDB StatsD 协议StatsD采用简单的行协议，StatsD Server默认采用UDP协议，可配置为 TCP协议 12345&lt;bucket&gt;:&lt;value&gt;|&lt;type&gt;[|@sample_rate]* bucket: Metric 标识* value: Metric 数值* type: Metric 类型* sample_rate: 采样率 StatsD Metric Types Counting计数 123456people.number:10|c -- people.number +10people.number:2|c -- people.number 10+2 = 12people.number:-5|c -- people.number 12-5 = 7people.number:10|c|@0.1 -- people.number 7+10/0.1=107flush 107current people.number 107 Timing记录操作耗时，StatsD 会计算出平均值、标准差、最大值、最小值 people.number.api.mean_$PCTpeople.number.api.sum_$PCTpeople.number.api.upper_$PCT PCT表示百分比阀值，可配置 123456789101112people.number.api:10|mspeople.number.api:101|mspeople.number.api:20|mspeople.number.api:15|mspeople.number.api:11|msflush前值列表为 [10,101,20,15,11]假设 PCT为80 则刷新上报的值为: 1. 首先剔除10%的峰值：5*0.8 = 4 (四舍五入) ，保留4个值，剔除剩余峰值101。当前[10,20,15,11]2. 平均值: (10+20+15+11)/4 最大值: 20 最小值: 10current people.number.api 0 Gauges在flush后值不会被清零 123456cat.food.amount:10|g -- cat.food.amount +10cat.food.amount:-2|g -- cat.food.amount 10-2=8cat.food.amount:+5|g -- cat.food.amount 8+5=13cat.food.amount:10|g -- cat.food.amount 10flush 10 current cat.food.amount 10 Sets统计不重复的值有多少个 123456active.people.id:2|g -- active.people.id +1active.people.id:1|g -- active.people.id 1+1 = 2active.people.id:1|g -- active.people.id 2active.people.id:10|g -- active.people.id 2+1 = 3flush 3 current active.people.id 0 GraphiteGraphite 由三部分构成 carbon监听时间序列数据 whisper存储时间序列数据 graphite-web展示时间序列数据 Graphite &amp; StatsD 安装1docker run -it --name graphite --restart=always -p 8080:80 -p 2003-2004:2003-2004 -p 2023-2024:2023-2024 -p 8125:8125/udp -p 8126:8126 -d graphiteapp/graphite-statsd 访问Graphite123http://host:8080/dashboard默认用户密码为：root/root修改用户密码：http://host:8080/admin/auth/user/1/ Grafana官方是这么说的：No matter where your data is, or what kind of database it lives in, you can bring it together with Grafana. Beautifully Grafana安装1docker run -it --name=grafana --restart=always -p 3000:3000 -d grafana/grafana 访问Grafana12http://host:3000默认用户/密码：admin/admin 配置数据源 Metrics数据模拟1while true; do echo -n &quot;people.number:$((RANDOM % 100))|c&quot; | nc -w 1 -u 127.0.0.1 8125; done 设置Grafana图表]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码质量持续约束]]></title>
    <url>%2F2019%2F01%2F17%2F%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E6%8C%81%E7%BB%AD%E7%BA%A6%E6%9D%9F%2F</url>
    <content type="text"><![CDATA[基于Docker的代码质量持续约束流程搭建为了提高团队整体的代码质量，有必要搭建一套持续的代码约束流程。本文记录基于Docker如何搭建自动化代码检测流程 创建网络方便组件间通过容器名通信 docker network create -d bridge --subnet=10.0.0.0/24 cicd_bridge GitLab开源的代码托管平台，集成了CI/CD 启动docker run -it --network=cicd_bridge -p 443:443 -p 80:80 -p 22:22 --name gitlab_cicd --restart always -v ~/DockerVolumeCicd/gitlab/config:/etc/gitlab -v ~/DockerVolumeCicd/gitlab/logs:/var/log/gitlab -v ~/DockerVolumeCicd/gitlab/data:/var/opt/gitlab -d gitlab/gitlab-ce:latest 访问 http://127.0.0.1 首次登陆设置密码为：adminadmin ,使用 root用户名登陆 创建一个spring 测试项目 设置 GitLab 扩展url 并 重启vi ~DockerVolumeCicd/gitlab/config/gitlab.rb docker restart gitlab_cicd GitLab RunnerGitLab Runner用于运行.gitlab-ci.yml中定义的Jobs，Jobs的执行结果会被发送到GitLab，GitLab Runner与GitLab CI（持续集成服务） 集成使用。GitLab Runner由Go语言实现 启动docker run -it --network=cicd_bridge --name gitlab-runner_cicd --restart always -v /var/run/docker.sock:/var/run/docker.sock -v ~/DockerVolumeCicd/gitlab-runner/conf:/etc/gitlab-runner/ -d gitlab/gitlab-runner:latest 获取 Runner Token 注册 Runnerdocker exec -it gitlab-runner_cicd gitlab-ci-multi-runner register 或者命令指定注册： docker exec -it gitlab-runner_cicd gitlab-ci-multi-runner register --non-interactive --executor &quot;docker&quot; --docker-image maven:3.5-jdk-8 --url &quot;http://gitlab_cicd&quot; --registration-token &quot;NDcNdmx5jaQxka8Ua3sn&quot; --description &quot;docker-runner&quot; --tag-list &quot;whw&quot; --run-untagged --locked=&quot;false&quot; --docker-network-mode =cicd_bridge 配置注册信息vi ~/DockerVolumeCicd/gitlab-runner/conf/config.toml SonarQubeSonarQube是一个代码质量管理系统，支持多种语言分析，提供重复代码、编码标准、单元测试、代码覆盖率、代码复杂度、潜在Bug的报告分析 启动docker run -it --network=cicd_bridge -p 9000:9000 --name sonarqube_cicd --restart always -v ~/DockerVolumeCicd/sonar/conf:/opt/sonarqube/conf -v ~/DockerVolumeCicd/sonar/data:/opt/sonarqube/data -v ~/DockerVolumeCicd/sonar/logs:/opt/sonarqube/logs -v ~/DockerVolumeCicd/sonar/extensions:/opt/sonarqube/extensions -d sonarqube 访问 http://127.0.0.1:9000 user/pwd 默认为 admin/admin 首次登陆配置 安装Java语言插件 AND 刷新页面Restart SonarQube .gitlab-ci.yml在项目的根目录添加.gitlab-ci.yml文件，用于定义Jobs1234567891011121314151617181920212223242526272829303132333435363738394041424344image: maven:3.5-jdk-8stages: - build - test - sonarqubevariables: MAVEN_OPTS: &quot;-Dmaven.repo.local=.m2/repository&quot;cache: paths: - .m2/repository - target/build: stage: build only: - release-test - develop script: - mvn clean install -Dmaven.test.skip tags: - whwtest: stage: test only: - release-test - develop script: - mvn test tags: - whw allow_failure: truesonarqube: stage: sonarqube only: - release-test - develop script: - mvn sonar:sonar -Dsonar.host.url=http://sonarqube_cicd:9000 -Dsonar.language=java tags: - whw GitLab &amp; GitLab Runner &amp; GitLab CI当有项目代码提交到GitLab的时候，GitLab会通知到GitLab CI，GitLab CI根据配置的Jobs将任务分发给指定的GitLab Runner，GitLab Runner 执行配置好的的Piplelines]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kafka On Docker]]></title>
    <url>%2F2018%2F10%2F13%2FKafka-On-Docker%2F</url>
    <content type="text"><![CDATA[记录在Docker上创建单broker的Kafka过程 安装运行Kafka创建bridge网络1docker network create -d bridge --subnet=10.0.0.0/24 kafka_net 启动zookeeper1docker run --restart=always -d -ti --name zookeeperService --network=kafka_net -p 2181:2181 -v /home/core/zookeeper/conf:/conf -v /home/core/zookeeper/data:/data -v /home/core/zookeeper/dataLog:/dataLog zookeeper 验证zookeeper是否启动正常1docker run --rm -it --network=host zookeeper zkCli.sh -server localhost:2181 启动Kafka1docker run -it --name kafkaService --network=kafka_net -p 9092:9092 -e KAFKA_ADVERTISED_HOST_NAME=localhost -e KAFKA_ZOOKEEPER_CONNECT=zookeeperService:2181 -d wurstmeister/kafka 运行上述命令后发现启动日志报错，错误信息显示系统内存不总 1OpenJDK 64-Bit Server VM warning: INFO: os::commit_memory(0x00000000bad30000, 986513408, 0) failed; error=&apos;Cannot allocate memory&apos; (errno=12) 查看kafka启动脚本，发现默认配置的JVM堆内存为1G，本机空闲内存只有67M，系统并未开启swap区 1234free -mhtotal used free shared buff/cache availableMem: 988Mi 682Mi 67Mi 200Mi 238Mi 17MiSwap: 0B 0B 0B 开启swap区使用文件添加swap区 dd if=/dev/zero of=/swap-file bs=1M count=1024 chmod 0600 /swap-file mkswap /swap-file 格式化交换分区 swapon /swap-file 启动交换分区 swapon -s 查看交换分区 Swappiness Swappiness的取值范围为0～100，通过修改/proc/sys/vm/swappiness文件的值来设置vm.swappiness = 0，系统尽可能的使用物理内存，在避免用尽之前才进行swap操作vm.swappiness = 100，系统主动的进行swap操作 再次启动Kafka，并覆盖JVM对内存参数 1docker run -d -ti --name kafkaService --network=kafka_net -p 9092:9092 -e KAFKA_ADVERTISED_HOST_NAME=localhost -e KAFKA_ZOOKEEPER_CONNECT=zookeeperService:2181 -e KAFKA_HEAP_OPTS=&quot;-Xmx200M -Xms200M&quot; wurstmeister/kafka 验证Kafka是否启动成功123456789Producer:docker run --rm -it --network=host ryane/kafkacat -b localhost:9092 -t myTopic -PHello World !Consumer:docker run --rm -it --network=host ryane/kafkacat -b localhost:9092 -t myTopic -C % Reached end of topic myTopicTest [0] at offset 0Hello World !% Reached end of topic myTopicTest [0] at offset 1 swap区的活动1234567891011121314vmstat 1procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st19 5 355328 61092 160 149916 95 35 482 54 29 45 1 1 97 1 0 9 10 355840 60640 176 148624 2784 1060 112192 1212 2420 5863 2 43 0 56 016 4 355328 59268 176 149840 2048 612 112268 680 2163 5319 2 32 0 66 014 20 355840 58216 168 151556 2876 1360 150376 1580 2960 6953 1 50 0 49 010 9 355584 57344 168 152156 1780 728 151144 772 2318 5504 1 42 0 57 019 0 355328 57852 200 150296 3528 676 114896 888 2900 5972 1 63 0 36 017 15 355584 54752 148 154576 2660 1216 165028 1528 2636 5672 1 55 0 44 011 4 355584 54008 188 155416 2896 1268 111956 1336 3175 6713 13 56 0 31 020 12 355840 58968 192 150796 2176 992 136236 1244 2453 6017 1 36 0 64 027 2 355328 55616 200 152832 3192 832 108232 992 2393 5416 2 39 0 60 0 虽然Kafka启动成功了，但是频繁的swap区交换导致系统响应变慢 查看Kafka对swap区的使用 获取容器应用在宿主机中的PID cat /sys/fs/cgroup/memory/docker/{container_id}/cgroup.procs 获取进程地址信息 sudo cat /proc/{PID}/smaps | head -n20 123456789101112131415161718192021222324本例Kafka的PID为10250：sudo cat /proc/10250/smaps | head -n20f3800000-100400000 rw-p 00000000 00:00 0Size: 208896 kBKernelPageSize: 4 kBMMUPageSize: 4 kBRss: 76048 kBPss: 76048 kBShared_Clean: 0 kBShared_Dirty: 0 kBPrivate_Clean: 68 kBPrivate_Dirty: 75980 kBReferenced: 56888 kBAnonymous: 76048 kBLazyFree: 0 kBAnonHugePages: 55296 kBShmemPmdMapped: 0 kBShared_Hugetlb: 0 kBPrivate_Hugetlb: 0 kBSwap: 129208 kB // 使用的swap区空间SwapPss: 129208 kBLocked: 0 kB 启动Kafka Manager123docker run --restart=always -d -ti --name=kafkaManager --network=kafka_net -p 9000:9000 -e ZK_HOSTS=zookeeperService:2181sheepkiller/kafka-manager]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
        <tag>Swap分区</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collection与Map]]></title>
    <url>%2F2018%2F09%2F09%2FCollection%E4%B8%8EMap%2F</url>
    <content type="text"><![CDATA[记录下Java中常用的Collection与Map Collection常用的集合类图 常用Collection对比 Map常用的Map类图 常用Map对比]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mutex]]></title>
    <url>%2F2018%2F09%2F07%2Fmutex%2F</url>
    <content type="text"><![CDATA[记录下多线程情况下，如何避免资源竞争带来的问题 资源竞争多线程在运行期间，若存在数据的共享，不同线程对资源的争抢会造成彼方线程的处理错乱。下面是两个线程将数值从零累加10次的例子（预计结果为10） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Count implements Runnable &#123; private int countResult = 0; @Override public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; count(); &#125; &#125; private void count() &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; int temp = countResult; countResult++; System.out.println(Thread.currentThread().getName() + &quot; Count Before &quot; + temp + &quot;, Count After &quot; + countResult); &#125; public void countResult() &#123; System.out.println(&quot;The result of count is &quot; + countResult); &#125;&#125;Count count = new Count();Thread t1 = new Thread(count, &quot;T1&quot;);Thread t2 = new Thread(count, &quot;T2&quot;);t1.start();t2.start();t1.join();t2.join();count.countResult();// 输出T1 Count Before 0, Count After 1T2 Count Before 1, Count After 2T1 Count Before 2, Count After 3T2 Count Before 3, Count After 4T2 Count Before 5, Count After 6T1 Count Before 4, Count After 6T2 Count Before 6, Count After 7T1 Count Before 7, Count After 8T1 Count Before 8, Count After 9T2 Count Before 8, Count After 9The result of count is 9 // 并非是预期的结果 10 当线程或进程依赖某一资源（代码中的countResult），会发生资源竞争。使针对资源的操作互斥，能够解决资源竞争带来的结果不可预测 关键字synchronizedJava中提供了Synchronize关键字来解决资源竞争问题 123456789101112131415161718192021222324252627private synchronized void count() &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; int temp = countResult; countResult++; System.out.println(Thread.currentThread().getName() + &quot; Count Before &quot; + temp + &quot;, Count After &quot; + countResult);&#125;// 将资源依赖的代码方法上加上 synchronized 关键字，问题得到解决 T1 Count Before 0, Count After 1 T1 Count Before 1, Count After 2 T1 Count Before 2, Count After 3 T1 Count Before 3, Count After 4 T1 Count Before 4, Count After 5 T2 Count Before 5, Count After 6 T2 Count Before 6, Count After 7 T2 Count Before 7, Count After 8 T2 Count Before 8, Count After 9 T2 Count Before 9, Count After 10 The result of count is 10 synchronized方法与方法块线程想进入synchronized修饰的代码的前提是先获得对象的监视器锁 synchronized修饰方法，则需要先获得当前实例对象的监视器锁 synchronized修饰代码块，则需要先获得synchronized所指定对象的监视器锁(修饰代码块更方便控制同步的范围) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class SynchronizedTest &#123; public synchronized void syncMethod() &#123; try &#123; syncBlock(); TimeUnit.SECONDS.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public void noSyncMethod() &#123; try &#123; TimeUnit.SECONDS.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public void syncBlock() &#123; synchronized (this) &#123; System.out.println(Thread.currentThread().getName() + &quot;:I am in syncBlock&quot;); try &#123; TimeUnit.SECONDS.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;SynchronizedTest synchronizedTest = new SynchronizedTest();Thread tOne = new Thread(() -&gt; synchronizedTest.syncMethod(), &quot;One&quot;);tOne.start(); // 获取对象实例（synchronizedTest）监视器锁,并可重入监视器锁（可以执行syncBlock）Thread tTwo = new Thread(() -&gt; synchronizedTest.syncMethod(), &quot;Two&quot;);tTwo.start(); // 等待tOne释放对象监视器锁，BLOCKED状态Thread tThree = new Thread(() -&gt; synchronizedTest.noSyncMethod(), &quot;Three&quot;);tThree.start(); // 不需要对象监视器锁即可执行Thread tFour = new Thread(() -&gt; synchronizedTest.syncBlock(), &quot;Four&quot;);tFour.start(); // 等待释放对象监视器锁，BLOCKED状态System.out.println(&quot;One will be TIMED_WAITING: &quot; + tOne.getState());System.out.println(&quot;Two will be BLOCKED: &quot; + tTwo.getState());System.out.println(&quot;Three will be TIMED_WAITING: &quot; + tThree.getState());System.out.println(&quot;Four will be BLOCKED: &quot; + tFour.getState());tOne.join();tTwo.join();tThree.join();tFour.join();// 输出One:I am in syncBlockOne will be TIMED_WAITING: TIMED_WAITINGTwo will be BLOCKED: BLOCKEDThree will be TIMED_WAITING: TIMED_WAITINGFour will be BLOCKED: BLOCKEDFour:I am in syncBlockTwo:I am in syncBlockProcess finished with exit code 0 多个线程同时阻塞等待进入同步块，当锁持有者离开同步块，这些等待的线程谁能进入同步块是不确定的，因为同步是不公平的（先来的不一定先进入同步块），这种不公平可能导致Thread Starvation 监视器锁synchronized到底是什么？为啥可以控制资源竞争。先看看编译后的字节码 1234567891011121314151617181920212223242526272829303132333435363738394041424344Mac:ThreadExamples mac$ javac SynchronizedMethodBlock.javaMac:ThreadExamples mac$ javap -c SynchronizedMethodBlock.classCompiled from &quot;SynchronizedMethodBlock.java&quot;public class dmztest.ThreadExamples.SynchronizedMethodBlock &#123; public dmztest.ThreadExamples.SynchronizedMethodBlock(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return public synchronized void syncMethod(); // 关键字synchronized用在方法上，则由JVM级别实现同步 Code: 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #3 // String I am sync Method ! 5: invokevirtual #4 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return public void syncBlock(); Code: 0: aload_0 1: dup 2: astore_1 // 尝试获得对象的监视器 ，每个对象都拥有一个监视器 // 当monitor为0说明monitorenter能够获得监视器，线程获得监视器后将monitor+1,该线程为对象monitor所有者 // 具有monitor所有者的线程能够重新进入监视器monitor+1。如果非monitor持有者的线程尝试monitorenter将会阻塞，直到monitor=0后获取monitor拥有权 3: monitorenter 4: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 7: ldc #5 // String I am sync Block ! 9: invokevirtual #4 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 12: aload_1 13: monitorexit // 释放monitor所有权,只有拥有monitor的线程才可以释放,释放后monitor-1,monitor为0时则线程失去monitor所有权 14: goto 22 17: astore_2 18: aload_1 19: monitorexit // 当代码块中出现异常则会释放monitor拥有权 20: aload_2 21: athrow 22: return Exception table: from to target type 4 14 17 any 17 20 17 any&#125; 关键字synchronized在方法上与在代码块上的功能是一样的，方法上的synchronized成为JVM对此方法上的访问标志，方法块上的synchronized会填充一系列字节码到class中 synchronized锁优化synchronized是互斥锁（重量级锁），互斥会带来用户态到内核态的线程切换的性能问题。在JDK1.6以后对synchronized进行了优化，synchronized的同步来自JVM的实现，由C++实现CAS，利用CPU指令执行原子操作（cmpxchg汇编指令，当多核CPU情况下会加lock） 锁粗化：将多个连续的锁扩展为范围更大的锁，减少频繁的互斥同步导致的性能开销 锁消除：JVM即时编译器在运行时，通过逃逸分析出”如果一段代码中堆数据永远不会被其他线程访问”则将锁取消 轻量级锁：在没有多线程竞争的情况下，避免重量级的互斥锁，通过CAS完成锁的获取与释放 偏向锁：消除数据在无竞争的情况下执行同步，若下一次同一线程进入，则偏向该线程，无需任何同步操作 适应性自旋：避免线程频繁切换的消耗，使用自旋的方式。适应性自旋的时间会根据上一次获取锁自旋的时间动态变化 不适合synchronized的应用场景 中断阻塞在获取监控锁的线程 公平的获得监视器锁 LockLock相比synchronized更加灵活，synchronized无法解决的场景Lock可以解决 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class ThreadWithInterrupt &#123; private Lock lock = new ReentrantLock(); public void write() &#123; try &#123; lock.lock(); long startTime = System.currentTimeMillis(); System.out.println(&quot;写数据。。。&quot;); for (; ; ) &#123; if (System.currentTimeMillis() - startTime &gt; 10000) &#123; break; &#125; &#125; System.out.println(&quot;数据写完了！&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void read() throws InterruptedException &#123; System.out.println(&quot;等待数据读。。。&quot;); lock.lockInterruptibly(); try &#123; System.out.println(&quot;数据读完了。&quot;); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125;ThreadWithInterrupt threadWithInterrupt = new ThreadWithInterrupt();Thread write = new Thread(() -&gt; threadWithInterrupt.write());Thread read = new Thread(() -&gt; &#123; try &#123; threadWithInterrupt.read(); &#125; catch (InterruptedException e) &#123; System.out.println(&quot;数据未读。&quot;); &#125;&#125;);write.start();read.start();new Thread(() -&gt; &#123; long startTime = System.currentTimeMillis(); for (;;) &#123; if (System.currentTimeMillis() - startTime &gt; 500) &#123; System.out.println(&quot;写的太慢了，不读了。&quot;); read.interrupt(); break; &#125; &#125;&#125;).start();// 输出写数据。。。等待数据读。。。写的太慢了，不读了。数据未读。数据写完了！Process finished with exit code 0 ReentrantLock可重入锁，当前线程持有lock后可再次获得此锁。重入锁包括公平锁与不公平锁，公平锁保证先发起的lock请求会先获得锁，后发起的lock请求后获得锁，非公平锁则不能保证“先来先锁” 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889class ThreadLockFairOrNon &#123; private Lock lock; private Integer concurrency; public ThreadLockFairOrNon(Boolean isFair, Integer concurrency) &#123; this.lock = new ReentrantLock(isFair); this.concurrency = concurrency; &#125; public Boolean isSeqSorted(List&lt;String&gt; seqs) &#123; if (!String.valueOf(concurrency).equals(seqs.get(concurrency))) &#123; return false; &#125; return true; &#125; public Boolean lockSequence() &#123; List&lt;String&gt; seqs = new ArrayList&lt;&gt;(); CountDownLatch waitForFirstThreadCount = new CountDownLatch(1); CountDownLatch waitForAllThreadCount = new CountDownLatch(concurrency + 1); CountDownLatch waitForSeqThreadCount = new CountDownLatch(concurrency - 1); try &#123; new Thread(() -&gt; &#123; try &#123; lock.lock(); waitForFirstThreadCount.countDown(); seqs.add(Thread.currentThread().getName()); waitForSeqThreadCount.await(); lock.unlock(); waitForAllThreadCount.countDown(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;, &quot;0&quot;).start(); waitForFirstThreadCount.await(); for (int j = 1; j &lt;= concurrency - 1; j++) &#123; new Thread(() -&gt; &#123; waitForSeqThreadCount.countDown(); lock.lock(); seqs.add(Thread.currentThread().getName()); lock.unlock(); waitForAllThreadCount.countDown(); &#125;, &quot;&quot; + j).start(); &#125; waitForSeqThreadCount.await(); // 准备争抢 new Thread(() -&gt; &#123; try &#123; lock.lock(); seqs.add(Thread.currentThread().getName()); lock.unlock(); waitForAllThreadCount.countDown(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;, &quot;&quot; + concurrency).start(); waitForAllThreadCount.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return isSeqSorted(seqs); &#125;&#125; FairSync 事例 12345678910111213141516Integer wrongSeqs = 0;for (int i = 0; i &lt; 1000; i++) &#123; Boolean isSeqsSorted = new ThreadLockFairOrNon(true, 100).lockSequence(); if (!isSeqsSorted) &#123; wrongSeqs++; &#125;&#125;System.out .println(&quot;1000 samples cause wrong seqs :&quot; + wrongSeqs + &quot; times&quot;); // 输出1000 samples cause wrong seqs :0 times 源码 1234567891011121314151617181920212223242526272829final void lock() &#123; acquire(1);&#125;public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125;protected final boolean tryAcquire(int acquires) &#123;final Thread current = Thread.currentThread();int c = getState();if (c == 0) &#123; if (!hasQueuedPredecessors() &amp;&amp; ## 排队等待，很公平 compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125;&#125;else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) throw new Error(&quot;Maximum lock count exceeded&quot;); setState(nextc); return true;&#125; return false;&#125; NonfairSync 事例 12345678910111213141516Integer wrongSeqs = 0;for (int i = 0; i &lt; 1000; i++) &#123; Boolean isSeqsSorted = new ThreadLockFairOrNon(false, 100).lockSequence(); if (!isSeqsSorted) &#123; wrongSeqs++; &#125;&#125;System.out .println(&quot;1000 samples cause wrong seqs :&quot; + wrongSeqs + &quot; times&quot;); // 输出1000 samples cause wrong seqs :950 times 源码 123456789101112131415161718192021222324252627282930313233343536final void lock() &#123; if (compareAndSetState(0, 1)) ## 插队！不公平 setExclusiveOwnerThread(Thread.currentThread()); else acquire(1);&#125;public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125;protected final boolean tryAcquire(int acquires) &#123; return nonfairTryAcquire(acquires);&#125;final boolean nonfairTryAcquire(int acquires) &#123;final Thread current = Thread.currentThread();int c = getState();if (c == 0) &#123; if (compareAndSetState(0, acquires)) &#123; ## 插队！不公平 setExclusiveOwnerThread(current); return true; &#125;&#125;else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error(&quot;Maximum lock count exceeded&quot;); setState(nextc); return true;&#125; return false;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java线程基础]]></title>
    <url>%2F2018%2F08%2F20%2FJava%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[记录下Java中多线程的使用 线程的生命周期 NEW：线程被创建未启动 RUNNABLE：线程为启动状态，被虚拟机执行或者是等待系统资源中 WAITING：线程调用 Object.wait、Thread.join或LockSupport.park方法，线程进入WAITING状态 TIMED_WAITING：线程调用 Thread.sleep 、Object.wait(10) 、Thread.join(10)、LockSupport.parkNanos 或 LockSupport.parkUntil方法 ，线程进入TIMED_WAITING状态 BLOCKED：线程等待获取锁 TERMINATED：线程死亡 线程的状态123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687class ThreadStates extends Thread &#123; @Override public void run() &#123; try &#123; threadCurrentState(&quot;RUNNABLE&quot;, this); TimeUnit.SECONDS.sleep(5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public void entryMonitor() &#123; try &#123; synchronized (ThreadStates.class) &#123; TimeUnit.SECONDS.sleep(3); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public void threadCurrentState(String name, Thread thread) &#123; System.out.println(name + &quot;&apos;s state is &quot; + thread.getState()); &#125; public void newRunnableTimedWaitingTerminated() throws InterruptedException &#123; threadCurrentState(&quot;NEW&quot;, this); this.start(); TimeUnit.SECONDS.sleep(1); threadCurrentState(&quot;TIMED_WAITING&quot;, this); Runtime.getRuntime().addShutdownHook(new Thread(() -&gt; threadCurrentState(&quot;TERMINATED&quot;, this))); Thread joinT = new Thread(() -&gt; entryMonitor()); joinT.start(); Thread thread = Thread.currentThread(); new Thread(() -&gt; &#123; try &#123; Thread blockedT = new Thread(() -&gt; entryMonitor()); blockedT.start(); TimeUnit.SECONDS.sleep(1); threadCurrentState(&quot;BLOCKED&quot;, blockedT); TimeUnit.SECONDS.sleep(1); threadCurrentState(&quot;WAITING&quot;, thread); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;).start(); joinT.join(); &#125;&#125;try &#123; new ThreadStates().newRunnableTimedWaitingTerminated();&#125; catch (InterruptedException e) &#123; e.printStackTrace();&#125;// 输出NEW&apos;s state is NEWRUNNABLE&apos;s state is RUNNABLETIMED_WAITING&apos;s state is TIMED_WAITINGBLOCKED&apos;s state is BLOCKEDWAITING&apos;s state is WAITINGTERMINATED&apos;s state is TERMINATEDProcess finished with exit code 0 线程的创建与启动下面是几种在Java中运行线程的方式 继承Thread 123456789101112131415161718class ThreadExtend extends Thread &#123; public ThreadExtend() &#123; super(); &#125; public ThreadExtend(String name) &#123; super(name); &#125; @Override public void run() &#123; System.out.println(&quot;I&apos;m &quot;+getName()+&quot;, coming from extend&quot;); &#125;&#125;new ThreadExtend(&quot;ThreadExtend&quot;).start(); 实现Runnable接口 1234567891011121314151617class ThreadRunnable implements Runnable &#123; private String name; public ThreadRunnable(String name) &#123; this.name = name; &#125; @Override public void run() &#123; System.out.println(&quot;I&apos;m &quot;+name+&quot;, coming from runnable&quot;); &#125;&#125;new Thread(new ThreadRunnable(&quot;ThreadRunnable&quot;)).start(); 实现Callable接口 12345678910111213141516171819class ThreadWithCallable implements Callable&lt;String&gt; &#123; @Override public String call() &#123; return &quot;Thread Callable&quot;; &#125;&#125;ThreadWithCallable threadWithCallable = new ThreadWithCallable();FutureTask&lt;String&gt; futureTask = new FutureTask(threadWithCallable);new Thread(futureTask).start();try &#123; System.out.println(futureTask.get());&#125; catch (InterruptedException e) &#123; e.printStackTrace();&#125; catch (ExecutionException e) &#123; e.printStackTrace();&#125; 基于线程池 1234ExecutorService executorService = Executors.newFixedThreadPool(2);executorService.submit(new ThreadExtend());System.out.println(executorService.submit(new ThreadWithCallable()).get());executorService.shutdown(); 线程常用的相关方法sleepsleep()是线程的方法，此方法会使线程睡眠，sleep()不会释放当前线程已经拥有的监视器。若其他线程线程调用了睡眠线程的interrupt()方法或sleep的时间已到，则线程进入Runnable状态 12345678910111213141516long waitingTime = 10;Thread sleepThread = new Thread(() -&gt; &#123; try &#123; System.out.println(&quot;I&apos;m gonna go to bed !&quot;); TimeUnit.SECONDS.sleep(waitingTime); System.out.println(&quot;I was waken up !&quot;); &#125; catch (InterruptedException e) &#123; System.out.println(&quot;I was interrupted !&quot;); &#125;&#125;);sleepThread.start();sleepThread.interrupt(); Object#wait &amp; notify/notifyAll wait()是Object类中定义的方法，当线程持有了Object的监视器才可以调用Object的wait()方法，wiat()会释放持有的监视器。假设当前线程获得了对象锁，则当其他线程试图获得此对象锁时，会导致线程阻塞（Blocked） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class WaitNotifyTest implements Serializable &#123; private List&lt;Integer&gt; queue = new ArrayList&lt;&gt;(); private int CAPACITY = 5; public static void main(String[] args) &#123; WaitNotifyTest waitNotify = new WaitNotifyTest(); Thread produceT = new Thread(waitNotify.new Produce()); Thread consumerT = new Thread(waitNotify.new Consumer()); produceT.start(); consumerT.start(); &#125; class Produce implements Runnable &#123; int count; @Override public void run() &#123; while (true) &#123; try &#123; produce(count++); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; private void produce(int count) throws InterruptedException &#123; synchronized (queue) &#123; if (queue.size() == CAPACITY) &#123; System.out.println(&quot;Queue is Full...&quot;); queue.wait(); System.out.println(&quot;Produce wait over !&quot;); return; &#125; Thread.sleep(1000); queue.add(count); System.out.println(&quot;Produced :&quot; + count); queue.notify(); &#125; &#125; &#125; class Consumer implements Runnable &#123; @Override public void run() &#123; while (true) &#123; try &#123; consume(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; private void consume() throws InterruptedException &#123; synchronized (queue) &#123; if (queue.isEmpty()) &#123; System.out.println(&quot;Queue is Empty...&quot;); queue.wait(); System.out.println(&quot;Consume wait over !&quot;); return; &#125; Thread.sleep(1000); int i = queue.remove(0); System.out.println(&quot;Consumed :&quot; + i); queue.notify(); &#125; &#125; &#125;&#125; wait()方法 123456public final void wait() throws InterruptedException &#123; wait(0); // 是个本地方法&#125;public final native void wait(long timeout) throws InterruptedException; // 其他线程调用notify()/notifyAll()可以唤醒由wait()方法导致waiting的线程（或者wait等待的时间过期） LockSupport#park &amp; unpark park()功能同wait()，只是wait在调用前必须先获得监视器。对于线程的唤醒来说，unpark可以唤醒指定的线程，而notify/notifyAll无法唤醒指定的线程 123456789101112131415161718192021222324252627class ForWakeUpThread implements Runnable &#123; private Thread waitForWakeUp; public ForWakeUpThread(Thread thread) &#123; this.waitForWakeUp = thread; &#125; @Override public void run() &#123; try &#123; Thread.sleep(10000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;Wake Up Main Thread !&quot;); LockSupport.unpark(waitForWakeUp); &#125;&#125;ForWakeUpThread wakeUpT = new ForWakeUpThread(Thread.currentThread());new Thread(wakeUpT).start();LockSupport.park();System.out.println(&quot;Main Thread Over !&quot;); Condition#await &amp; signal await()支持多个等待队列，监视器锁只有一个等待队列，当notify/notifyAll被调用的时候系统无法知道该唤醒消费者还是生产者。await()与signal()利用了LockSupport#park/unpark方法将线程阻塞与唤醒 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class LockConditionTest implements Serializable &#123; private List&lt;Integer&gt; queue = new ArrayList&lt;&gt;(); private Lock lock = new ReentrantLock(); private Condition produce = lock.newCondition(); private Condition consume = lock.newCondition(); private int CAPACITY = 5; public static void main(String[] args) &#123; LockConditionTest waitNotify = new LockConditionTest(); Thread produceT = new Thread(waitNotify.new Produce()); Thread consumerT = new Thread(waitNotify.new Consumer()); produceT.start(); consumerT.start(); &#125; class Produce implements Runnable &#123; int count; @Override public void run() &#123; while (true) &#123; try &#123; produce(count++); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; private void produce(int count) throws InterruptedException &#123; try &#123; lock.lock(); if (queue.size() == CAPACITY) &#123; System.out.println(&quot;Queue is Full...&quot;); produce.await(); System.out.println(&quot;Produce wait over !&quot;); return; &#125; Thread.sleep(1000); queue.add(count); System.out.println(&quot;Produced :&quot; + count); consume.signal(); &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; class Consumer implements Runnable &#123; @Override public void run() &#123; while (true) &#123; try &#123; consume(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; private void consume() throws InterruptedException &#123; try &#123; lock.lock(); if (queue.isEmpty()) &#123; System.out.println(&quot;Queue is Empty...&quot;); consume.await(); System.out.println(&quot;Consume wait over !&quot;); return; &#125; Thread.sleep(1000); int i = queue.remove(0); System.out.println(&quot;Consumed :&quot; + i); produce.signal(); &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; join join()方法会阻塞调用此方法的线程，当线程执行结束（或者join的时间过期）则等待的线程会继续运行 123456789101112131415161718192021class JoinThreadPartOne implements Runnable &#123; @Override public void run() &#123; try &#123; TimeUnit.SECONDS.sleep(10); System.out.println(&quot;Thread Part One Is Over !&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;Thread partOneT = new Thread(new JoinThreadPartOne());partOneT.start();partOneT.join(); // 阻塞主线程，当partOneT执行结束，主线程将继续执行System.out.println(&quot;Main Thread Is Over !&quot;);System.in.read(); join方法 12345678910111213141516171819202122232425262728public final void join() throws InterruptedException &#123; join(0);&#125;public final synchronized void join(long millis) // 调用此方法需要获取监视器throws InterruptedException &#123; long base = System.currentTimeMillis(); long now = 0; if (millis &lt; 0) &#123; throw new IllegalArgumentException(&quot;timeout value is negative&quot;); &#125; if (millis == 0) &#123; while (isAlive()) &#123; wait(0); // 调用的是wait()方法 &#125; &#125; else &#123; while (isAlive()) &#123; long delay = millis - now; if (delay &lt;= 0) &#123; break; &#125; wait(delay); now = System.currentTimeMillis() - base; &#125; &#125;&#125; priority线程可以设置优先级，优先级较高的线程优先于具有较低优先级的线程执行（并非绝对的优先，由系统尽量保证，所以线程优先级不能作为编码的逻辑控制）。线程优先级因不同的操作系统而有所不同 1234567891011121314151617181920212223242526272829303132333435363738class ThreadPriority extends Thread &#123; private int priority; private boolean shouldYield; private String name; public ThreadPriority(int priority, boolean shouldYield, String name) &#123; this.priority = priority; setPriority(priority); this.shouldYield = shouldYield; this.name = name; &#125; @Override public void run() &#123; System.out.println(&quot;Thread &quot; + name + &quot; With &quot; + priority + &quot; Priority Start&quot;); try &#123; TimeUnit.SECONDS.sleep(5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; if (shouldYield) &#123; System.out.println(&quot;Thread &quot; + name + &quot; With &quot; + priority + &quot; Priority Yield&quot;); Thread.yield(); &#125; System.out.println(&quot;Thread &quot; + name + &quot; With &quot; + priority + &quot; Priority End&quot;); &#125;&#125;ThreadPriority minPriorityT = new ThreadPriority(Thread.MIN_PRIORITY, false,&quot;A&quot;);ThreadPriority maxPriorityT = new ThreadPriority(Thread.MAX_PRIORITY, false,&quot;B&quot;);minPriorityT.start();maxPriorityT.start(); yieldyield()方法是让出当前线程使用的CPU时间片，也就是当前线程让出的CPU时间片让其他同等优先级的线程使用。让出的意图是否被系统接受（如线程优先级一样）完全看系统心情 123456ThreadPriority minPriorityT = new ThreadPriority(Thread.MIN_PRIORITY, true,&quot;A&quot;);ThreadPriority maxPriorityT = new ThreadPriority(Thread.MIN_PRIORITY, false,&quot;B&quot;);minPriorityT.start();maxPriorityT.start(); interrupt中断线程的执行，由操作系统向线程发送事件信号 12345678910111213141516171819202122232425class ThreadInterrupt implements Runnable &#123; @Override public void run() &#123; for(;;) &#123; boolean isInterrupt = Thread.currentThread().isInterrupted(); if (isInterrupt) &#123; System.out.println(&quot;Current Thread&apos;s isInterrupt &quot; + isInterrupt); return; &#125; &#125; &#125;&#125;Thread interruptT = new Thread(new ThreadInterrupt());interruptT.start();TimeUnit.SECONDS.sleep(10);System.out.println(&quot;Interrupt ThreadInterrupt !&quot;);interruptT.interrupt();interruptT.join(); daemon若线程设置为守护线程，则当虚拟机中的所有用户线程结束或虚拟机退出，相应的守护线程随之结束（当用户线程都结束了，守护线程的使命即终止）。在守护线程中创建的线程也是守护线程，在用户线程中创建的是线程也是用户线程，线程池框架会将守护线程转为用户线程。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128class DaemonThread implements Runnable &#123; @Override public void run() &#123; MemoryMXBean memorymbean = ManagementFactory.getMemoryMXBean(); MemoryUsage usage = memorymbean.getHeapMemoryUsage(); for (; ; ) &#123; try &#123; TimeUnit.SECONDS.sleep(2); System.out.println(&quot;INIT HEAP: &quot; + usage.getInit() / 1024 / 1024 + &quot;MB&quot;); System.out.println(&quot;MAX HEAP: &quot; + usage.getMax() / 1024 / 1024 + &quot;MB&quot;); System.out.println(&quot;USE HEAP: &quot; + usage.getUsed() / 1024 / 1024 + &quot;MB&quot;); System.out.println(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;class AliveThread implements Runnable &#123; @Override public void run() &#123; for(;;) &#123; try &#123; TimeUnit.SECONDS.sleep(2); System.out.println(&quot;I&apos;m alive !&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;// 1.System.exit(0) 会退出虚拟机，无论当前是否有守护、用户线程运行Thread daemonT = new Thread(new DaemonThread());daemonT.setDaemon(true);Thread aliveT = new Thread(new AliveThread());daemonT.start();aliveT.start();System.out.println(&quot;Main Thread Over !&quot;);TimeUnit.SECONDS.sleep(5);System.exit(0); // 1.输出Main Thread Over !I&apos;m alive !INIT HEAP: 64MBMAX HEAP: 910MBUSE HEAP: 5MBI&apos;m alive !INIT HEAP: 64MBMAX HEAP: 910MBUSE HEAP: 5MBProcess finished with exit code 0// 2.JVM等待所有用户线程执行完成后才会退出Thread aliveT = new Thread(new AliveThread());aliveT.start();System.out.println(&quot;Main Thread Over !&quot;);// 2.输出Main Thread Over !I&apos;m alive !I&apos;m alive !I&apos;m alive !I&apos;m alive !I&apos;m alive !I&apos;m alive !I&apos;m alive !（无限执行下去）// 3.用户线程都执行完成后，JVM退出Thread daemonT = new Thread(new DaemonThread());daemonT.setDaemon(true);System.out.println(&quot;Main Thread Over !&quot;);// 3.输出INIT HEAP: 64MBMAX HEAP: 910MBUSE HEAP: 5MBINIT HEAP: 64MBMAX HEAP: 910MBUSE HEAP: 5MBMain Thread Over !Process finished with exit code 0// 4.守护线程一直守护用户线程Thread daemonT = new Thread(new DaemonThread());daemonT.setDaemon(true);Thread aliveT = new Thread(new AliveThread());daemonT.start();aliveT.start();System.out.println(&quot;Main Thread Over !&quot;);// 4.输出Main Thread Over !I&apos;m alive !INIT HEAP: 64MBMAX HEAP: 910MBUSE HEAP: 6MBI&apos;m alive !INIT HEAP: 64MBMAX HEAP: 910MBUSE HEAP: 6MBI&apos;m alive !INIT HEAP: 64MBMAX HEAP: 910MBUSE HEAP: 6MBI&apos;m alive !INIT HEAP: 64MBMAX HEAP: 910MBUSE HEAP: 6MB（无限执行下去） 多线程可能产生的问题Thread Starvation如果一个线程一直得不到共享的资源（为什么其他线程都会得到资源，而我一直不能。。），这个线程就很“饥饿”，即 Thread Starvation。导致线程饥饿的原因： 线程进入同步方法造成的阻塞等待,可能导致线程饥饿 高优先级的线程抢走资源，可能导致低优先级的线程饥饿 调用了wait()方法的线程，notify()不能保证所有线程的wait都终止，可能导致线程饥饿 公平锁公平锁会公平的分配多线程竞争的资源，避免导致线程饥饿 Thread Deadlock假设当前有线程A和B，线程A获得资源AA的锁并尝试获得资源BB的锁，而此时线程B已经获得了资源BB的锁并尝试获得资源AA的锁 –&gt;产生死锁，死锁状态下的线程状态为BLOCKED。如同不懂退让的两只山羊过桥,两只羊各先占一半桥，同时又都需要对方的那一半桥 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class DeadLockOccur &#123; private Object sourceALock = new Object(); private Object sourceBLock = new Object(); public void needA_B() &#123; synchronized (sourceALock) &#123; try &#123; TimeUnit.SECONDS.sleep(1); synchronized (sourceBLock) &#123; TimeUnit.SECONDS.sleep(2); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public void needB_A() &#123; synchronized (sourceBLock) &#123; try &#123; TimeUnit.SECONDS.sleep(1); synchronized (sourceALock) &#123; TimeUnit.SECONDS.sleep(2); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;DeadLockOccur deadLock = new DeadLockOccur();Thread ABT = new Thread(() -&gt; deadLock.needA_B());Thread BAT = new Thread(() -&gt; deadLock.needB_A());ABT.start();BAT.start();TimeUnit.SECONDS.sleep(2);System.out.println(&quot;ABT will be BLOCKED:&quot; + ABT.getState());System.out.println(&quot;BAT will be BLOCKED:&quot; + BAT.getState());// 输出ABT will be BLOCKED:BLOCKEDBAT will be BLOCKED:BLOCKED 将上例中所需资源一次性锁定可以解决死锁问题 12345678910111213141516171819202122232425private Object sourceABLock = new Object(); public void needA_B() &#123; synchronized (sourceABLock) &#123; try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public void needB_A() &#123; synchronized (sourceABLock) &#123; try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; Thread Livelock线程的活锁指的是线程间都在“为对方考虑”，对方存活就把资源让给对方，这样互相谦让自己的资源，最后反而谁都得不到资源，活锁状态下的线程状态为RUNNABLE。有没有遇到过这种情况：你走在路上迎面来了个人，你躲让到一边想让对方通过，在这同时对方也躲让到了你躲让的这一边（你们又面对面了），如此反复 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Worker &#123; private String name; private boolean active; public Worker(String name, boolean active) &#123; this.name = name; this.active = active; &#125; public synchronized void work(Worker otherWorker) &#123; while (active) &#123; if (otherWorker.active) &#123; try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(name + &quot; handover the resource to &quot; + otherWorker.name); continue; &#125; System.out.println(name + &quot; working on the resource&quot;); active = false; &#125; &#125;&#125;Worker w1 = new Worker(&quot;Work1&quot;, true);Worker w2 = new Worker(&quot;Work2&quot;, true);Thread w1T = new Thread(() -&gt; w1.work(w2));Thread w2T = new Thread(() -&gt; w2.work(w1));w1T.start();w2T.start();// 输出Work1 handover the resource to Work2Work2 handover the resource to Work1Work1 handover the resource to Work2Work2 handover the resource to Work1Work1 handover the resource to Work2Work2 handover the resource to Work1（无限执行下去） 资源顺序的执行可以避免上述的活锁]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发与多线程]]></title>
    <url>%2F2018%2F08%2F18%2F%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[记录下并发与多线程的一些知识 并发的前提多核CPU与缓存 多处理器与多核心 多处理器：即多个独立的CPU单元 多核心：每个CPU单元有单个或多个核心，当存在多核心的CPU运行多线程时，那么这些线程是可以并行的。单核心的CPU是否不存在线程的并行？并非如此，若单核心的CPU拥有Hyper-threading技术，那么单核心可以并行的运行两个逻辑线程 并发/并行 Concurrency 指的是运行的多线程间存在资源的共享（或者运行的多线程会执行同一段代码片段）。单核、多核都可能存在并发，这种并发若不做相应的控制则会引起安全问题。并发多指发生在同一时间段 Parallelism 指的是在多个独立的核心或多个独立的CPU上运行的多线程，并行不存在线程间的数据共享，需要硬件支持（多核、多处理器）。并行发生在同一时刻 并发的场景 多进程/多任务：单个CPU下的并发，如在使用QQ的同时打开爱奇艺看剧 多线程/子任务：单个应用下的并发，如博客网站可以处理不同用户的访问请求 上下文切换上下文切换是操作系统有能力实现多任务的重要特性。在单CPU单核心的硬件环境中，CPU需要记录当前进程或线程的运行状态，这样在切换到另一个进程或线程结束后，可以再次正确的切换回当前的进程或线程。上下文切换会带来一定的CPU消耗，因为CPU需要消耗额外的时间来挂起执行的线程并且记录、恢复线程的执行状态。上下文切换由线程调度实现 进程是资源分配的最小单元，线程是CPU调度的最小单元 并发带来的问题并发就是最大限度的压榨CPU能力，并发是把双刃剑，提高吞吐量/响应速度的同时也带来了一些问题 资源竞争问题：并发的读写会导致结果依赖于读写操作的顺序，而这种顺序是不可控的 内存一致性问题：多线程共同可见一块内存，当某一线程修改了共享内存区域的数据，可能导致其他线程不可见。在Java中使用Volatile关键字能够解决缓存一致性问题 线程互斥针对并发的问题，常用的解决方案是使用互斥锁（Lock/Synchronize），互斥锁会使线程调度将多线程的执行强制为串行，互斥控制可能会导致其他CPU资源的浪费]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Find Soul And See It]]></title>
    <url>%2F2018%2F07%2F12%2Fsoul%2F</url>
    <content type="text"><![CDATA[Seven times I have despised my soul:The first time when I saw her being meek that she might attain height.The second time when I saw her limping before the crippled.The third time when she was given to choose between the hard and the easy, and she chose the easy.The fourth time when she committed a wrong, and comforted herself that others also commit wrong.The fifth time when she forbode for weakness, and attributed her patience to strength.The sixth time when she despised the ugliness of a face, and knew not that it was one of her own masks.And the seventh time when she sang a song of praise, and deemed it a virtue. –Kahlil Gibran–]]></content>
      <tags>
        <tag>M&amp;M</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ IDEA With Git]]></title>
    <url>%2F2018%2F05%2F21%2FIntelliJ%20IDEA%20With%20Git%2F</url>
    <content type="text"><![CDATA[记录下Git如何与IntelliJ IDEA协作 环境准备 Git下载 IntelliJ IDEA下载 IntelliJ IDEA 的 License server 可以使用：http://8lovelife.com:1017 IntelliJ IDEA With Git 开发过程1. 初次获取远端代码 使用IntelliJ IDEA Terminal 12Mac:code mac$ git clone https://github.com/grpc/grpc-java.gitCloning into &apos;grpc-java&apos;... 2. 查看远端仓库分支12345Mac:dmz-inward- mac$ git branch -av* master 0388b70 some feture remotes/origin/HEAD -&gt; origin/master remotes/origin/feature cd52891 some features remotes/origin/master 0388b70 some feture 3. 将指定的远端分支同步到本地（建议同远端名一致）123Mac:dmz-inward- mac$ git checkout -b feature origin/featureBranch &apos;feature&apos; set up to track remote branch &apos;feature&apos; from &apos;origin&apos;.Switched to a new branch &apos;feature&apos; 4. 查看本地当前所在分支 &amp; 关联的远端分支1234567891011Mac:dmz-inward- mac$ git branch // 查看当前分支* feature master Mac:dmz-inward- mac$ git branch -avv // 查看当前分支关联的远端分支* feature bb87089 [origin/feature] Merge branch &apos;feature_test&apos; into feature feature_test dd90129 // master 0388b70 [origin/master] some feture remotes/origin/HEAD -&gt; origin/master remotes/origin/feature bb87089 Merge branch &apos;feature_test&apos; into feature remotes/origin/master 0388b70 some feture View 确认 5. 准备在指定分支开发12Mac:dmz-inward- mac$ git checkout -b feature_testSwitched to a new branch &apos;feature_test&apos; 6. coding &amp; show diff coding 随时查看本地的变动，防止遗漏： 7. 将文件添加到暂存区 &amp; 提交工作分支的修改 | 更改提交的comments123456789101112Mac:dmz-inward- mac$ git add . // 添加暂存区Mac:dmz-inward- mac$ git commit -m &quot;feature add test&quot; // 提交[feature_test 7590940] feature add test 2 files changed, 7 insertions(+) create mode 100644 dmz-inward-test/src/test/java/Test.java Mac:dmz-inward- mac$ git commit --amend // 修改提交的comments[feature_test 90b9e43] feature add retests Date: Mon May 21 10:40:06 2018 +0800 2 files changed, 7 insertions(+) create mode 100644 dmz-inward-test/src/test/java/Test.java 暂存区与HEAD 8. 撤销本地的修改 9. 切换到与远端同步的主分支 &amp; 同步可能的远端修改123456Mac:dmz-inward- mac$ git checkout feature // 切换分支Switched to branch &apos;feature&apos;Your branch is up to date with &apos;origin/feature&apos;.Mac:dmz-inward- mac$ git pull // 同步远端可能的修改Already up to date. 10. 切换到工作分支 &amp; rebase | resoleve conflicts1234567891011Mac:dmz-inward- mac$ git checkout feature_test Switched to branch &apos;feature_test&apos;Mac:dmz-inward- mac$ git rebase featureCurrent branch feature_test is up to date.若rebase遇到冲突则手动解决，利用Intelli Idea 的show diff 可以清晰观察冲突点冲突解决后进行：git add * git rebase --continue 11. 切换到主分支 &amp; 合并修改到主分支12345678910Mac:dmz-inward- mac$ git checkout featureSwitched to branch &apos;feature&apos;Your branch is up to date with &apos;origin/feature&apos;.Mac:dmz-inward- mac$ git merge --no-ff feature_testMerge made by the &apos;recursive&apos; strategy. dmz-inward-test/src/test/java/Test.java | 6 ++++++ dmz-inward-test/src/test/java/TestFast.java | 1 + 2 files changed, 7 insertions(+) create mode 100644 dmz-inward-test/src/test/java/Test.java 分支 12.本地分支同步到远端分支（会改变远程分支的文件）1234567Mac:dmz-inward- mac$ git pushCounting objects: 17, done.Delta compression using up to 4 threads.Compressing objects: 100% (17/17), done.Writing objects: 100% (17/17), 1.36 KiB | 698.00 KiB/s, done.Total 17 (delta 10), reused 0 (delta 0)remote: Resolving deltas: 100% (10/10), completed with 4 local objects. Git 相关Git 常用的操作命令 回退到分支指定版本 查看分支历史变动历史，回退指定版本号 12Mac:dmz-inward- mac$ git reset --hard bb8708981a01eb568d114ed7ddad71f6cd881f7eHEAD is now at bb87089 Merge branch &apos;feature_test&apos; into feature Cherry-Pick将某一分支的commit修改，应用到当前本地分支。如：将feature上的某一commit修改应用到master上 123Mac:dmz-inward- mac$ git checkout masterSwitched to branch &apos;master&apos;Your branch is up to date with &apos;origin/master&apos;. Cherry-Pick Intellij Idea With Git 开发过程 本地分支重命名1Mac:dmz-inward- mac$ git branch -m feature feature_rename 本地新建分支推送到远端12345Mac:dmz-inward- mac$ git push --set-upstream origin feature_oneTotal 0 (delta 0), reused 0 (delta 0)To https://github.com/dreamming/dmz-inward-.git * [new branch] feature_one -&gt; feature_oneBranch &apos;feature_one&apos; set up to track remote branch &apos;feature_one&apos; from &apos;origin&apos;. 删除本地分支 &amp; 删除远端分支12345678Mac:dmz-inward- mac$ git branch -d feature_one // 删除本地分支warning: deleting branch &apos;feature_one&apos; that has been merged to &apos;refs/remotes/origin/feature_one&apos;, but not yet merged to HEAD.Deleted branch feature_one (was dd90129).Mac:dmz-inward- mac$ git push origin :feature_one // 删除远端分支To https://github.com/dreamming/dmz-inward-.git - [deleted] feature_one 查看版本变动 查看分支历史变动 123456789Mac:dmz-inward- mac$ git reflog47128b4 (HEAD -&gt; master, origin/master, origin/HEAD) HEAD@&#123;0&#125;: commit: //0388b70 HEAD@&#123;1&#125;: checkout: moving from feature to masterbb87089 (feature_two, feature) HEAD@&#123;2&#125;: checkout: moving from master to feature0388b70 HEAD@&#123;3&#125;: checkout: moving from feature to masterbb87089 (feature_two, feature) HEAD@&#123;4&#125;: reset: moving to bb8708981a01eb568d114ed7ddad71f6cd881f7e06d0579 (origin/feature) HEAD@&#123;5&#125;: commit: __bb87089 (feature_two, feature) HEAD@&#123;6&#125;: checkout: moving from master to feature0388b70 HEAD@&#123;7&#125;: checkout: moving from feature_one to master 查看文件更改人]]></content>
      <tags>
        <tag>IntelliJ IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[volatile]]></title>
    <url>%2F2018%2F05%2F15%2Fvolatile%2F</url>
    <content type="text"><![CDATA[线程间的通信线程间的通信方式有：共享内存和消息传递 共享内存多个线程通过读写内存中的共享对象来隐式的进行通信。如Java中的对象 消息传递线程间通过发送消息显示的进行通信。如Java中的wait()/notify() 线程间共享内存线程间共享的对象都在主存中，每个线程都会有一块私有的本地内存称为栈，线程栈中存储了共享对象的副本 线程安全线程安全包括几个方面的内容：1。原子性 2。可见性 3。有序性 原子性(执行控制-代码顺序)原子性提供了多线程间代码指令的互斥访问。如:Synchronized、Lock 可见性一个线程对共享内存数据的修改是否会立刻被其他线程感知到？多线程间的共享数据访问会由于缓存的不一致性导致数据错乱 有序性编译器或处理器为了优化指令的执行效率，无数据依赖关系的指令执行顺序会被重新排序(在单线程环境下，指令重排序执行的最终结果应该与其在顺序执行下的效果一致，即 as-if-serial semantics)。然而多线程下会因为不同的执行顺序 ，导致不同的结果 12345678910111213String content;boolean isReadable;void write()&#123; content = &quot;Some Contents&quot;; isReadable = true;&#125;void doWork()&#123; while(isReadable)&#123; System.out.println(content) &#125;&#125; 假设线程A运行的write()方法中代码顺序进行了重排序，则线程B运行的doWrok()中并不一定能够读到更改后的content！ 数据依赖存在数据依赖的语句不会被重排序，如下图的数据依赖关系 数据依赖 示例 写后读 x = 10 ; y=x 写后写 x=10 ; x=20 读后写 y=x ; x=5 JMM中确保的有序性如果两个操作的执行顺序无法从happens-before原则推导出来，那么就不能保证操作的有序性，JVM可以对它们进行随意的重排序。happens-before原则如下： 程序次序规则：单线程内，按照代码顺序执行，书写在前的代码先发生于书写在后的代码 锁定规则：一个unLock操作先发生于后面的lock操作之前 volatile原则：一个volatile变量的写操作先发生于后面对这个变量的读操作 传递原则：A操作先发生于B操作，B操作先发生于C操作 ，则A操作先发生于C操作 Thread启动原则：Thread的start()操作先发生于此线程的其他操作 Thread中断原则：Thread的interrupt()操作先发生于代码对线程中断事件的检测 Thread终止原则：Thread的所以操作都先发生于线程的终止检测 对象终结原则：对象的初始化完成先发生于对象的finalize()方法的开始 volatile如果字段被声明为volatile，JMM确保所有线程看到这个变量的值是一致的。JMM通过volatile声明来隐藏处理针对不同处理器下的数据缓存一致性问题,使用Lock前缀或者内存屏障。计算机中的缓存一致性方案有两种：总线锁机制和MESI协议（缓存一致性协议） volatile的作用 禁止指令重排序 强制将缓存的修改立即写入主存 如果是写操作，将导致其他CPU对应的缓存行无效 volatile不能保证执行的原子性，无法保证原子性的操作都不能保证线程的安全 禁止指令重排序 在执行volatile读写操作语句时，在此之前的语句全部已经进行，且结果已经对后面的操作可见 在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2F2018%2F04%2F21%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[记录下单例模式的几种实现 单例模式单例类保证在系统中始终只有一份类的实例，单例模式能够节约内存空间，对于整个系统中共性的逻辑可以采用单例模式。分布式系统中ZK就像是整个系统中的”单例” 单例的实现单例的实现方式有多种，根据实例化时机可分为饿汉、懒汉模式 饿汉模式12345678910public class Singleton &#123; private static final Singleton singleton = new Singleton(); private Singleton() &#123; &#125; public static Singleton getInstance() &#123; return singleton; &#125;&#125; 单例在类的加载时就完成了类的实例（即使这个类还没被使用） 懒汉模式1234567891011121314151617public class Singleton &#123; private static Singleton singleton; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125; double check 既保证了类的延迟加载，又降低了synchronize带来的累积性能消耗。但这个单例在多线程环境下存在安全隐患 指令重排序singleton = new Singleton(); 这段代码并非原子操作（开辟内存空间-&gt;类的初始化-&gt;引用变量赋值），为了提高性能，程序会进行指令的重排序如（开辟内存空间-&gt;引用变量赋值-&gt;类的初始化），多线程环境下会存在线程拿到未实例完成的类 1234567891011121314151617public class Singleton &#123; private volatile static Singleton singleton; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125; volatile禁止指令重排序 静态内部类123456789public class Singleton &#123; private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; private Singleton ()&#123;&#125; public static final Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125;&#125; 只有在调用getInstance()时才会加载静态内部类SingletonHolder（JVM保证类的加载是线程安全的），从而实例化Singleton 枚举123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public enum Singleton &#123; INSTANCE; Object object; Singleton() &#123; object = new Object(); &#125; public Object getInstance() &#123; return object; &#125;&#125;Mac:src mac$ javac -encoding utf-8 Singleton.java Mac:src mac$ javap -c Singleton.classCompiled from &quot;Singleton.java&quot;public final class Singleton extends java.lang.Enum&lt;Singleton&gt; &#123; public static final Singleton INSTANCE; java.lang.Object object; public static Singleton[] values(); Code: 0: getstatic #1 // Field $VALUES:[LSingleton; 3: invokevirtual #2 // Method &quot;[LSingleton;&quot;.clone:()Ljava/lang/Object; 6: checkcast #3 // class &quot;[LSingleton;&quot; 9: areturn public static Singleton valueOf(java.lang.String); Code: 0: ldc #4 // class Singleton 2: aload_0 3: invokestatic #5 // Method java/lang/Enum.valueOf:(Ljava/lang/Class;Ljava/lang/String;)Ljava/lang/Enum; 6: checkcast #4 // class Singleton 9: areturn public java.lang.Object getInstance(); Code: 0: aload_0 1: getfield #9 // Field object:Ljava/lang/Object; 4: areturn static &#123;&#125;; Code: 0: new #4 // class Singleton 3: dup 4: ldc #10 // String INSTANCE 6: iconst_0 7: invokespecial #11 // Method &quot;&lt;init&gt;&quot;:(Ljava/lang/String;I)V 10: putstatic #12 // Field INSTANCE:LSingleton; 13: iconst_1 14: anewarray #4 // class Singleton 17: dup 18: iconst_0 19: getstatic #12 // Field INSTANCE:LSingleton; 22: aastore 23: putstatic #1 // Field $VALUES:[LSingleton; 26: return&#125;public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt; implements Comparable&lt;E&gt;, Serializable 枚举类的字节码可以看出，枚举在使用的时候（懒加载）触发类的初始化（线程安全），枚举类已经实现了序列化接口]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM类加载]]></title>
    <url>%2F2018%2F04%2F21%2FJVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[回顾回顾JVM中的类加载 类的生命周期类的生命周期包括类的加载、链接、初始化、使用、销毁 类装入JVM将类装入JVM供使用的过程分为：类的加载、链接、初始化 显示装入：1。 调用类加载器中的loadClass方法 2。调用Class.forName方法 隐示装入：解析类中引用的其他类的时候，所引用的类未被加载时则被隐示装入 类的加载类的加载包括 将.class文件加载到JVM方法区中 在堆中生成Class对象，Class对象提供了访问方法区中类数据结构的接口 这一阶段类对象仅有基本的内存结构，类对象中的方法、字段、引用都不做处理，此时的类还不能使用 类的链接类的链接将内存中二进制数据转换到JVM运行数据区，链接包括验证、准备、解析 验证：验证类的字节码是否合法 准备：为类的静态变量分配内存并设置默认值 12final static int a = 10 准备阶段阶段 a 的默认值为 10static int b = 10 准备阶段 b 的默认值为 0 解析：将常量池中的符号引用替换为直接引用，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行 类的初始化类的初始化是执行&lt;clinit&gt;()方法的过程 &lt;clinit&gt;() 由编译器按照代码书写的顺序将类中的 静态变量的赋值与静态代码块 合并到此方法中 &lt;clint&gt;() 同时只能有一个线程且只能执行一次，利用这个特性可以写一个安全的懒加载单例类 类的初始化时机，若类未初始化则以下动作将进行类的初始化 new对象、调用静态方法、获取非final修饰的静态变量、设置静态变量 对类进行反射调用 类的初始化发生时，若有父类则先执行父类的类的初始化 虚拟机会对启动类（即含有main方法的类）进行类的初始化 类的使用实例化、使用对象方法等 类的卸载Class对象被回收、Class方法区中数据结构被卸载 类加载器ClassLoader用于将类加载在JVM中供使用 ClassLoader工作机制类的加载采用双亲委派模式 ClassLoader工作过程 缓存（是否已加载 委托父加载器 自己加载 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455抽象类ClassLoader核心方法：protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; synchronized (getClassLoadingLock(name)) &#123; // 类是否已经加载 Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; long t0 = System.nanoTime(); try &#123; if (parent != null) &#123; // 若类并未被加载则委托父加载器加载 c = parent.loadClass(name, false); &#125; else &#123; // 若没有父加载器则委托给启动加载器 c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); // 当前类加载器开始加载类 c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; resolveClass(c); //加载的类是否进行解析 &#125; return c; &#125; &#125; protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len, ProtectionDomain protectionDomain) throws ClassFormatError &#123; protectionDomain = preDefineClass(name, protectionDomain); String source = defineClassSourceLocation(protectionDomain); Class&lt;?&gt; c = defineClass1(name, b, off, len, protectionDomain, source); postDefineClass(c, protectionDomain); return c; &#125; findClass方法由不同的加载器实现定制（网络加载.class文件等 defineClass方法用与创建Class对象 双亲委派模式ClassLoader双亲委派模式的能与不能 双亲委派加载的好处 保证了Java核心类库的安全 JVM中能够支持隔离的类空间（不同加载器加载同一个class） SPI SPI（Service Provider Interface）是Java提供的位于核心类库中的接口，由第三方实现。如JDBC、JNDI等。按照ClassLoader的双亲委派模式，最终加载SPI的是Bootstrap ClassLoader，而SPI的实现类是由System ClassLoader加载的，最终只会加载失败。 针对SPI的接口Java使用线程上下文加载器(Thread.currentThread().getContextClassLoader())来显式加载SPI的实现]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM监控]]></title>
    <url>%2F2018%2F04%2F16%2FJVM%E7%9B%91%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[记录下如何监控JVM，包括JVM的线程、堆内存、CPU使用情况等 GC LOGGC日志能够反应JVM内存的动态分配回收状况、应用停顿的时间，是GC调优的依据 JVM配置查询 jmap -heap [pid] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647Mac:dmz-inward- mac$ jmap -heap 1016 （JDK1.8）Attaching to process ID 1016, please wait...Debugger attached successfully.Server compiler detected.JVM version is 25.40-b25using thread-local object allocation.Parallel GC with 4 thread(s)Heap Configuration: MinHeapFreeRatio = 0 MaxHeapFreeRatio = 100 MaxHeapSize = 1073741824 (1024.0MB) NewSize = 22020096 (21.0MB) MaxNewSize = 357564416 (341.0MB) OldSize = 45088768 (43.0MB) NewRatio = 2 SurvivorRatio = 8 MetaspaceSize = 21807104 (20.796875MB) CompressedClassSpaceSize = 1073741824 (1024.0MB) MaxMetaspaceSize = 17592186044415 MB G1HeapRegionSize = 0 (0.0MB)Heap Usage:PS Young GenerationEden Space: capacity = 16777216 (16.0MB) used = 11951560 (11.397895812988281MB) free = 4825656 (4.602104187011719MB) 71.23684883117676% usedFrom Space: capacity = 3145728 (3.0MB) used = 2879968 (2.746551513671875MB) free = 265760 (0.253448486328125MB) 91.55171712239583% usedTo Space: capacity = 3145728 (3.0MB) used = 0 (0.0MB) free = 3145728 (3.0MB) 0.0% usedPS Old Generation capacity = 45088768 (43.0MB) used = 857520 (0.8177947998046875MB) free = 44231248 (42.18220520019531MB) 1.9018483716388082% used4674 interned Strings occupying 366808 bytes. GC日志文件 -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCApplicationStoppedTime -XX:+PrintGCDateStamps -XX:+PrintHeapAtGC , GC前后输出堆内存大小 -Xloggc:[file] , GC信息输出到独立文件中 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=[file] ,记录 堆内存耗尽时的堆快照 -XX:ErrorFile=[file] ,记录JVM虚拟机本身的异常信息 1-XX:+PrintGCDetails -XX:+PrintGCApplicationStoppedTime -XX:+PrintHeapAtGC -Xloggc:/tmp/gc.log -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp/ -XX:ErrorFile=/tmp/JVM_Error.log 分析GC Log jstat GC、堆内存信息总情况 jstat -gcutil [pid] [intervel] [count] 123456789Mac:JDK mac$ jstat -gcutil 3157 500 2 S0 S1 E O M CCS YGC YGCT FGC FGCT GCT 0.00 0.00 52.00 97.79 66.51 69.76 3 0.022 2 0.067 0.089 0.00 0.00 52.00 95.80 66.51 69.76 3 0.022 2 0.067 0.089 S0 S1 E O M : 表示堆内存各区已使用空间的百分比 YGC FGC : 表示Young GC、Full GC 的次数 YGCT FGCT GCT : 表示YoungGC、Full GC 、GC 所用的时间 CCS : 压缩使用比例 年轻代GC情况 jstat -gcnew [pid] [intervel] [count] 12345678910Mac:JDK mac$ jstat -gcnew 3157 500 2 S0C S1C S0U S1U TT MTT DSS EC EU YGC YGCT 512.0 512.0 0.0 0.0 7 15 512.0 2048.0 1065.0 11 0.044 512.0 512.0 0.0 0.0 7 15 512.0 2048.0 1065.0 11 0.044 S0C S1C EC : S0、S1、E区大小(KB) S0U S1U EU : S0、S1、E区已使用大小(KB) TT : 对象在新生代存活的次数 MTT : 对象的最大年龄 DSS : 期待的Survivor区大小 年轻代内存统计 jstat -gcnewcapacity [pid] 123456Mac:JDK mac$ jstat -gcnewcapacity 3157 NGCMN NGCMX NGC S0CMX S0C S1CMX S1C ECMX EC YGC FGC 3072.0 13312.0 3072.0 4096.0 512.0 4096.0 512.0 12288.0 2048.0 15 14 NGCMN NGCMX : 年轻代最小、最大空间 NGC ：当前年轻代大小 年老代 jstat -gcold [pid] [intervel] [count] jstat -gcoldcapacity [pid] 元数据空间 jstat -gcmetacapacity [pid] 123456Mac:JDK mac$ jstat -gcmetacapacity 3157 MCMN MCMX MC CCSMN CCSMX CCSC YGC FGC FGCT GCT 0.0 1056768.0 4864.0 0.0 1048576.0 512.0 17 16 0.491 0.556 CCSMN CCSMX : 压缩类最小、最大空间 CCSC : 当前压缩类空间大小 命令行监控命令行监控可结合脚本共同使用 jcmd12345获取运行的JVM进程：jcmd -l获取JVM运行的时间：jcmd process_id VM.uptime获取系统属性：jcmd process_id VM.system_properties获取JVM调优参数：jcmd process_id VM.flags获取JVM线程信息：jcmd process_id Thread.print 堆快照文件jmap用于导出堆的快照文件，便于后续分析 123Mac:JDK mac$ jmap -dump:format=b,file=/Users/mac/IdeaProjects/JDK/heap.hprof 3157Dumping heap to /Users/mac/IdeaProjects/JDK/heap.hprof ...Heap dump file created 堆快照分析工具MAT 线程栈文件将线程栈信息导入文件jstack [pid] &gt; threaddump.out | jcmd [pid] Thread.print &gt; ./threaddump.out 1Mac:JDK mac$ jcmd 3157 Thread.print &gt; ./threaddump.out 分析线程栈 图形化监控JDK内置有jvisualvm 、jconsole 直观的图形化监控工具 VisualVM123通过命令行直接唤醒启动Mac:JDK mac$ jvisualvm Visual GCVisual GC提供图形化的JVM堆内存使用的动态监控，由VisualVM以插件的形式提供 设置插件更新地址按JDK需要选择 堆内存动态监控]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM调优]]></title>
    <url>%2F2018%2F04%2F13%2FJVM%E8%B0%83%E4%BC%98%2F</url>
    <content type="text"><![CDATA[JVM到底怎么优化啊？优化什么？为啥要优化。。？ 堆内存分配与回收时机 大家都知道JVM中的堆内存是分代的结构，来看看堆内存的开辟与回收的细节 堆内存的分配 Eden区：对于新创建的对象，一般都会在此区域，新生对象不见得都会在此区域 Survivor区：Young区经过Minor GC，存活下的对象一般都此区，Young区存活的对象不见得都会在此区域 Old 区：经受住了多次Minor GC，Full GC存活的对象，都在此区域 堆内存的回收 堆内存在Minor GC 与 Full GC发生的时候回收，那么Minor GC 、Full GC 什么时候发生呢。。 Minor GC Minor GC发生在Young区，当Eden区满时会触发Minor GC，新生代的对象一般存活的时间很短，Minor GC会很频繁，由于是复制算法所以执行时间较快 Full GC /Major GC Major GC 亦指 Full GC ，Full GC会对整个堆区进行内存回收。Full GC发生在以下情况 Old区空间不足会触发Full GC Perm区满后会触发Full GC（设置CMS GC的情况除外） 执行CMS GC的过程中有对象进入Old区，Old区不足会报 Concurrent Mode Failure 错误，并触发 Full GC Minor GC时检测之前晋升到Old区平均对象大小（这个平均晋升大小是靠不住的），1。若大于Old区剩余大小，则直接触发Full GC。 2。若小于Old区剩余大小，则查看HandlePromotionFailure是否开启，若开启则会触发Full GC System.gc()方法建议JVM进行Full GC，使用DisableExplicitGC可禁用Full GC的显示调用 JVM调优扩大年轻代堆空间 JVM尝试将新生对象放入Eden区，若Eden区空间不够则会将对象提前放入Old区。Minor GC的成本远低于Full GC ，因此可以将对象尽可能保留在年轻代 1234567891011121314151617181920212223242526JVM 参数：-Xmx20M -Xms20M -XX:+PrintGCDetails private static void OptimizeOne() &#123; int M = 1024 * 1024; byte[] b1 = new byte[2 * M]; // 2M byte[] b2 = new byte[2 * M]; byte[] b3 = new byte[2 * M]; byte[] b4 = new byte[2 * M]; byte[] b5 = new byte[2 * M]; byte[] b7 = new byte[2 * M]; &#125;GC Log：[GC (Allocation Failure) [PSYoungGen: 3890K-512K(6144K)] 3890K-2664K(19968K), 0.0033226 secs] [Times: user=0.01 sys=0.01, real=0.00 secs] [GC (Allocation Failure) [PSYoungGen: 4772K-512K(6144K)] 6924K-6768K(19968K), 0.0057943 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] [GC (Allocation Failure) [PSYoungGen: 4733K-496K(6144K)] 10989K-10864K(19968K), 0.0050538 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] [Full GC (Ergonomics) [PSYoungGen: 496K-0K(6144K)] [ParOldGen: 10368K-10747K(13824K)] 10864K-10747K(19968K), [Metaspace: 3061K-3061K(1056768K)], 0.0088463 secs] [Times: user=0.02 sys=0.01, real=0.01 secs] Heap PSYoungGen total 6144K, used 2209K [0x00000007bf980000, 0x00000007c0000000, 0x00000007c0000000) eden space 5632K, 39% used [0x00000007bf980000,0x00000007bfba84c8,0x00000007bff00000) from space 512K, 0% used [0x00000007bff00000,0x00000007bff00000,0x00000007bff80000) to space 512K, 0% used [0x00000007bff80000,0x00000007bff80000,0x00000007c0000000) ParOldGen total 13824K, used 10747K [0x00000007bec00000, 0x00000007bf980000, 0x00000007bf980000) object space 13824K, 77% used [0x00000007bec00000,0x00000007bf67ef40,0x00000007bf980000) Metaspace used 3117K, capacity 4496K, committed 4864K, reserved 1056768K class space used 340K, capacity 388K, committed 512K, reserved 1048576K 通过GC Log可以发现Young区的大小为6M ，适当调整年轻代大小 12345678910111213141516171819202122232425JVM 参数：-Xmx20M -Xms20M -Xmn10M -XX:+PrintGCDetails private static void OptimizeOne() &#123; int M = 1024 * 1024; byte[] b1 = new byte[2 * M]; // 2M byte[] b2 = new byte[2 * M]; byte[] b3 = new byte[2 * M]; byte[] b4 = new byte[2 * M]; byte[] b5 = new byte[2 * M]; byte[] b7 = new byte[2 * M]; &#125; GC Log:[GC (Allocation Failure) [PSYoungGen: 6153K-608K(9216K)] 6153K-4704K(19456K), 0.0059569 secs] [Times: user=0.01 sys=0.01, real=0.00 secs] [GC (Allocation Failure) --[PSYoungGen: 6991K-6991K(9216K)] 11087K-15191K(19456K), 0.0058702 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] [Full GC (Ergonomics) [PSYoungGen: 6991K-2560K(9216K)] [ParOldGen: 8200K-8192K(10240K)] 15191K-10752K(19456K), [Metaspace: 3159K-3159K(1056768K)], 0.0070982 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] Heap PSYoungGen total 9216K, used 4995K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000) eden space 8192K, 60% used [0x00000007bf600000,0x00000007bfae0c10,0x00000007bfe00000) from space 1024K, 0% used [0x00000007bfe00000,0x00000007bfe00000,0x00000007bff00000) to space 1024K, 0% used [0x00000007bff00000,0x00000007bff00000,0x00000007c0000000) ParOldGen total 10240K, used 8192K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000) object space 10240K, 80% used [0x00000007bec00000,0x00000007bf400168,0x00000007bf600000) Metaspace used 3187K, capacity 4496K, committed 4864K, reserved 1056768K class space used 347K, capacity 388K, committed 512K, reserved 1048576K 年轻代不留大对象 JVM将新生的对象放入Yong区，若对象一出生就超级大，针对后续新产生的对象可能会导致Young区小对象频繁的转入Old区 123456789101112131415161718JVM 参数：-Xmx20M -Xms20M -Xmn10M -XX:+PrintGCDetails private static void OptimizeTwo() &#123; int M = 1024 * 1024; byte[] b1 = new byte[3 * M]; // 3M &#125; GC Log:Heap PSYoungGen total 6144K, used 4914K [0x00000007bf980000, 0x00000007c0000000, 0x00000007c0000000) eden space 5632K, 87% used [0x00000007bf980000,0x00000007bfe4c8e8,0x00000007bff00000) from space 512K, 0% used [0x00000007bff80000,0x00000007bff80000,0x00000007c0000000) to space 512K, 0% used [0x00000007bff00000,0x00000007bff00000,0x00000007bff80000) ParOldGen total 13824K, used 0K [0x00000007bec00000, 0x00000007bf980000, 0x00000007bf980000) object space 13824K, 0% used [0x00000007bec00000,0x00000007bec00000,0x00000007bf980000) Metaspace used 3045K, capacity 4496K, committed 4864K, reserved 1056768K class space used 334K, capacity 388K, committed 512K, reserved 1048576K 新生对象直接占据了Eden区的87%，将新生的大对象直接放入Old区，有利于提升GC效率，设置对象大小阀值-XX:PretenureSizeThreshold=3M (此设置对 +UseParallelGC 无效) 123456789101112131415161718JVM 参数：-Xmx20M -Xms20M -Xmn10M -XX:+PrintGCDetails -XX:PretenureSizeThreshold=3M -XX:+UseParNewGC private static void OptimizeTwo() &#123; int M = 1024 * 1024; byte[] b1 = new byte[3 * M]; // 3M &#125; GC Log：Heap par new generation total 6144K, used 1947K [0x00000007bec00000, 0x00000007bf2a0000, 0x00000007bf2a0000) eden space 5504K, 35% used [0x00000007bec00000, 0x00000007bede6e40, 0x00000007bf160000) from space 640K, 0% used [0x00000007bf160000, 0x00000007bf160000, 0x00000007bf200000) to space 640K, 0% used [0x00000007bf200000, 0x00000007bf200000, 0x00000007bf2a0000) tenured generation total 13696K, used 3072K [0x00000007bf2a0000, 0x00000007c0000000, 0x00000007c0000000) the space 13696K, 22% used [0x00000007bf2a0000, 0x00000007bf5a0010, 0x00000007bf5a0200, 0x00000007c0000000) Metaspace used 3045K, capacity 4496K, committed 4864K, reserved 1056768K class space used 334K, capacity 388K, committed 512K, reserved 1048576K 可以发现3M的对象直接放入了Old区 对象的年龄 对象的年龄指经过Minor GC仍存活在Young区的次数，当对象超过指定的年龄后会被移动到Old区，年龄未超过设置的阀值一样可能会移动到Old区，当Survivor区中相同年龄大小的所有对象大小总和超过了Survivor区空间的一半（默认 -XX:TargetSurvivorRatio=50）则会被移动到Old区 123456789101112131415161718192021222324JVM 参数：-Xmx20M -Xms20M -Xmn10M -XX:+PrintGCDetails private static void OptimizeThree() &#123; int M = 1024 * 1024; byte[] b1 = new byte[2 * M]; // 2M byte[] b2 = new byte[2 * M]; byte[] b4 = new byte[2 * M]; b4 = null; byte[] b5 = new byte[2 * M]; byte[] b6 = new byte[2 * M]; &#125; GC Log:[GC (Allocation Failure) [PSYoungGen: 3891K-496K(6144K)] 3891K-2640K(19968K), 0.0031407 secs] [Times: user=0.01 sys=0.01, real=0.00 secs] [GC (Allocation Failure) [PSYoungGen: 4756K-496K(6144K)] 6900K-4712K(19968K), 0.0030381 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] Heap PSYoungGen total 6144K, used 4775K [0x00000007bf980000, 0x00000007c0000000, 0x00000007c0000000) eden space 5632K, 75% used [0x00000007bf980000,0x00000007bfdadd80,0x00000007bff00000) from space 512K, 96% used [0x00000007bff80000,0x00000007bfffc010,0x00000007c0000000) to space 512K, 0% used [0x00000007bff00000,0x00000007bff00000,0x00000007bff80000) ParOldGen total 13824K, used 4216K [0x00000007bec00000, 0x00000007bf980000, 0x00000007bf980000) object space 13824K, 30% used [0x00000007bec00000,0x00000007bf01e020,0x00000007bf980000) Metaspace used 3165K, capacity 4496K, committed 4864K, reserved 1056768K class space used 345K, capacity 388K, committed 512K, reserved 1048576K 设置对象年龄阀值 MaxTenuringThreshold 123456789101112131415161718192021222324JVM 参数：-Xmx20M -Xms20M -Xmn10M -XX:+PrintGCDetails -XX:MaxTenuringThreshold=1 private static void OptimizeThree() &#123; int M = 1024 * 1024; byte[] b1 = new byte[2 * M]; // 2M byte[] b2 = new byte[2 * M]; byte[] b4 = new byte[2 * M]; b4 = null; byte[] b5 = new byte[2 * M]; byte[] b6 = new byte[2 * M]; &#125;GC Log:[GC (Allocation Failure) [PSYoungGen: 4123K-512K(6144K)] 4123K-2648K(19968K), 0.0033229 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] [GC (Allocation Failure) [PSYoungGen: 4770K-32K(6144K)] 6906K-4692K(19968K), 0.0037061 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] Heap PSYoungGen total 6144K, used 4309K [0x00000007bf980000, 0x00000007c0000000, 0x00000007c0000000) eden space 5632K, 75% used [0x00000007bf980000,0x00000007bfdad6d0,0x00000007bff00000) from space 512K, 6% used [0x00000007bff80000,0x00000007bff88000,0x00000007c0000000) to space 512K, 0% used [0x00000007bff00000,0x00000007bff00000,0x00000007bff80000) ParOldGen total 13824K, used 4660K [0x00000007bec00000, 0x00000007bf980000, 0x00000007bf980000) object space 13824K, 33% used [0x00000007bec00000,0x00000007bf08d310,0x00000007bf980000) Metaspace used 3204K, capacity 4496K, committed 4864K, reserved 1056768K class space used 350K, capacity 388K, committed 512K, reserved 1048576K 对比可以发现，进行在第二次GC时，设置了对象年龄=1的对象被移到了Old区 提高系统吞吐量 减少GC执行的总时间，可以提升系统的吞吐量，可以使用关注吞吐量的ParallelGC 1java –Xmx3072m –Xms3072m –Xmn2G –Xss128k –XX:+UseParallelGC -XX:ParallelGCThreads=2 –XX:+UseParallelOldGC 提高系统响应时间 尽可能将新生对象留在Yong区来减少Full GC的次数，Minor GC的成本要小于Full GC 使用关注响应时间的CMS GC 稍大的Survivor空间、较高的目标存活率，可以使对象直接在Young区回收，而不必因空间不够进入Old区 最大堆等于最小堆，避免堆内存的震荡从而降低系统性能，堆内存变小必然会带来更多的GC次数 1java –Xmx3072m –Xms3072m –Xmn2G –Xss128k –XX:+UseParNewGC -XX:SurvivorRatio=8 -XX:TargetSurvivorRatio=90 –XX:+UseConcMarkSweepGC –XX:MaxTenuringThreshold=31 -XX:ParallelGCThreads=2]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序-归并排序]]></title>
    <url>%2F2018%2F04%2F11%2F%E6%8E%92%E5%BA%8F-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[怎么对数据进行排序？排序算法有多种，该使用哪种排序算法呢？回顾下时间复杂度较低的归并排序 归并排序 归并排序的核心分为两个部分。1。将待排序数据对半分，直到只剩一个元素。2。针对两部分的数据（每部分已经是有序的）进行排序，左半部分与右半部分进行排序 归并排序（递归方式）代码实现1234567891011121314151617181920212223242526272829303132333435public void mergeSortByRecursive(int[] data) &#123; long startTime = System.nanoTime(); mergeSortRecursive(0, data.length - 1, data, new int[data.length]); System.out.println(&quot;MergeSortRecursive Time Cost : &quot; + (System.nanoTime() - startTime) * 0.000001 +&quot; ms&quot;); checkSortedData(data,&quot;MergeSortRecursive&quot;);&#125; private void mergeSortRecursive(int lowIndex, int highIndex, int[] data, int[] temp) &#123; if (lowIndex &gt;= highIndex) &#123; return; &#125; int mid = ((highIndex - lowIndex) &gt;&gt; 1) + lowIndex; int startOne = lowIndex, endOne = mid, startTwo = mid + 1, endTwo = highIndex; mergeSortRecursive(startOne, endOne, data, temp); mergeSortRecursive(startTwo, endTwo, data, temp); mergeData(lowIndex, mid, highIndex, data, temp);&#125; private void mergeData(int lowIndex, int middle, int highIndex, int[] data, int[] temp) &#123; for (int i = lowIndex; i &lt;= highIndex; i++) &#123; temp[i] = data[i]; &#125; int leftStart = lowIndex, rightStart = middle + 1; int tempIndex = leftStart; while (leftStart &lt;= middle &amp;&amp; rightStart &lt;= highIndex) &#123; data[tempIndex++] = temp[leftStart] &lt; temp[rightStart] ? temp[leftStart++] : temp[rightStart++]; &#125; while (leftStart &lt;= middle) &#123; data[tempIndex++] = temp[leftStart++]; &#125;&#125; 递归归并排序示意图 上述的排序代码是理想状态下的，当排序的数据量较大的时候，1。使用递归的方式对数据进行分治，排序的过程将不能正常结束，递归达到一定的深度将导致栈内存溢出。2。merge排序过程中需要额外的存储空间 归并排序（迭代方式）迭代归并排序将不会出现栈内存溢出的问题，同时对于merge部分可以采用原地排序，降低空间复杂度 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051private void mergeSortByIterative(int[] data) &#123; for ( int block=1; block&lt;=data.length-1/2; block = 2*block) &#123; for (int left_start=0; left_start&lt;data.length-1; left_start += 2*block) &#123; int mid = left_start + block - 1 &lt; data.length-1 ? left_start + block - 1 : left_start-1; int right_end = (left_start + 2 * block - 1) &lt; data.length - 1 ? left_start + 2 * block - 1 : data.length-1; mergeDataInPlace(left_start,mid,right_end,data); &#125; &#125;&#125;private void mergeDataInPlace(int lowIndex, int middle, int highIndex, int[] data) &#123; int i = lowIndex; int j = middle + 1; while(i &lt; j &amp;&amp; j &lt;= highIndex) &#123; while(i &lt; j &amp;&amp; data[i] &lt;= data[j]) &#123; i++; &#125; int index = j; while(j &lt;= highIndex &amp;&amp; data[j] &lt;= data[i]) &#123; j++; &#125; swap(data, i, index-i, j-index); i += (j-index); &#125;&#125; private void swap(int arr[], int i, int k, int j) &#123; reverse(arr, i, i + k - 1); reverse(arr, i + k, i + k + j - 1); reverse(arr, i, i + k + j - 1);&#125; private void reverse(int[] arr, int i, int j) &#123; while(i &lt; j) &#123; arr[i] ^= arr[j]; arr[j] ^= arr[i]; arr[i] ^= arr[j]; i++; j--; &#125;&#125; 迭代归并排序示意图 归并的算法复杂度 将N个待排序的数据对半分，分到剩下单个元素为止，这个过程需要log2N次 针对两部分有序的数据进行排序，比较的次数介于 N ~ N/2 之间 时间复杂度：O(Nlog2N) 空间复杂度：O(1) ~ O(N) 实际运行效果时间与空间不可兼得来看看归并排序具体所需的时间，测试数据为0～20W的随机大小数字，20W个数据排序5次 迭代归并排序(归并部分采用In-Place) 排序次数 所需时间 1 20093.858586 ms 2 19864.726974999998 ms 3 19930.830952 ms 4 19667.228037999997 ms 5 19873.263419 ms 迭代归并排序(归并部分不采用In-Place) 排序次数 所需时间 1 69.183775 ms 2 45.25653 ms 3 36.282312 ms 4 38.270578 ms 5 35.130196999999995 ms merge部分算法不同，排序的整体时间天壤之别。。。In-Place merge虽然节省了空间，但是带来了更多的元素移动，更多的时间消耗。时间复杂度与空间复杂度不可兼得 Fork/Join排序来看看对千万级的数据量进行排序，时间情况如何。测试数据1000W 迭代归并排序 排序次数 所需时间 1 2690.39711 ms 2 2267.34402 ms 3 2423.867487 ms 4 2543.747986 ms 5 2409.55724 ms 归并排序先把大量的数据分为多个小量的数据（分治），然后合并小量的数据（合并），这不是在说Fork/Join的嘛,而且Fork/Join可以利用多核，那么利用Fork/Join排序会不会快一点？ Fork/Join归并排序 排序次数 所需时间 1 10921.404759 ms 2 16899.215443 ms 3 14746.151189 ms 4 14887.626859999998 ms 5 15565.447017999999 ms 不敢相信的速度，Fork/Join排序会消耗大量的内存空间，导致频繁的GC，归并排序分治的最小任务是1，Fork/Join虽能并行的处理排序，但任务如果分的过小，会带来更多的线程切换，相比单线程的迭代归并排序，反而需要更多的时间]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM GC]]></title>
    <url>%2F2018%2F04%2F06%2FJVM-GC%2F</url>
    <content type="text"><![CDATA[垃圾回收器垃圾回收器是内存回收的具体实现，Java有四类垃圾回收器，分别是： Serial Garbage Collector Parallel Garbage Collector CMS Garbage Collector G1 Garbage Collector 串行垃圾回收器 串行垃圾回收器是JVM Client模式下的默认GC，只使用一个单独的线程进行垃圾回收，垃圾回收时会冻结所有应用程序的线程，垃圾回收期间程序暂停的时间较长 Serial GC Serial GC为新生代的垃圾搜集器，采用复制回收算法。Java中所有新产生的对象都在Yong区中的Eden区，当Eden区的大小不足以容纳新生的对象或对象大小超过了PretenureSizeThreshold的参数配置大小 ，对象只能在Old区分配。当Eden区满后会触发Minor GC ，触法Minor GC前需要检查老年代的连续空间是否大于新生代总大小或者历届晋升对象的平均大小，若满足就会进行Minor GC，否则将进行Full GC。Minor GC除了清除Eden区的非活跃对象外，还会把Survivor区一些老对象移动到Old区，老对象的定义通过配置MaxTenuringThreshold大小来控制，1.当对象在Survivor区的存活次数达到MaxTenuringThreshold的大小则会被移动到Old区。 2.当Survivor区中相同年龄大小的所有对象大小总和超过了Survivor区空间的一半（默认 -XX:TargetSurvivorRatio=50）则会被移动到Old区 Serial Old GC Serial Old GC 为老年代搜集器，使用“标记-整理”算法，此GC不能够主动配置。1.当CMS收集器发生错误的时候使用。2.配合其他GC使用 并行垃圾回收器 Parallel GC 根据Minor GC 和 Full GC的不同分为三种，分别为：ParNewGC、ParallelGC，ParallelGC。并行垃圾回收器以多线程的方式进行回收 ParNewGC 属于新生代的GC，此垃圾搜集器的工作方式与Serial GC类似，只不过它是多线程的，垃圾回收器工作的时候同样需要停止程序的所有线程 ParNewGC组合参数 PretenureSizeThreshold ：此参数表示当对象的大小超过此值则直接进入Old区，只对Serial和ParNew两款收集器有效 UseAdaptiveSizePolicy：当这个参数打开之后，就不需要手工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold ）等细节参数了 Parallel GC JVM Server模式下默认的GC方式，即Parallel Scavenge，属于新生代GC。此垃圾搜集器与Par NewGC类似，不同地方在于Parallel Scavenge关注点是程序的吞吐量 吞吐量与响应时间 吞吐量：运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间），吞吐量高适合后台密集运算的程序 响应时间：程序停顿时间的大小，响应时间短适合应用与用户交互的程序 Parallel GC的组合参数 MaxGCPausedMillis：垃圾回收器将尽可能在此时间内完成完成内存回收，关注停顿时间 GCTimeRatio：设置垃圾搜集时间占总时间的比值，即：1-吞吐量，关注吞吐量 ParallelGCThreads：指定回收线程数 ParallelOldGC 属于老年代GC，以多线程的方式使用“标记-整理”算法 并发标记清除垃圾回收器 CMS（Concurrent Mark Sweep）收集器是以响应时间为目标的收集器，是老年代的GC，基于“标记-清除”算法。对于B/S系统的服务端，需要重视服务的响应速度。CMS的触发规则是检查Old区的使用率（设置参数为：CMSInitiatingOccupancyFraction），当达到一定的使用率则会触发CMS GC，当CMS GC正在进行的时候，若此时JVM正在向Old区申请内存，Old区内存不够则申请会失败并会触发Full GC CMS过程 Initial Mark: 初始化标记，标记对象根路径直接关联的对象，需要终止程序所有线程（Stop The World，单线程） Concurrent Mark: 并发标记，追踪根路径可达的对象 Concurrent precleaning: 并发预处理，查找并发标记阶段进入老年代的对象，减少下一阶段的停顿时间 Remark:重新标记，扫描从根对象开始向下追溯，并处理关联对象，需要终止程序所有线程（Stop The World，多线程） Concurrent sweeping: 并发清理垃圾对象 Concurrent reset: 并发重置，等待下一次垃圾回收 CMS使用 CMS收集方式能够减少程序停顿时间。“标记-清除”算法会产生大量的内存空间碎片 CMS组合参数 UseCMSCompactAtFullCollection：Full GC 后进行一次碎片整理，整理过程会Stop The World CMSFullGCsBeforeCompaction： 设置进行几次Full GC后进行碎片整理 ParallelCMSThreads：设置CMS线程数量 ExplicitGCInvokesConcurrent :设置当显示GC调用、只会触发CMS，不会进行Full GC G1垃圾收集器 G1垃圾回收器，将Java堆分为多个大小相等的区域（region），新生代与老年代对象耦合在一起 G1 GC过程 标记阶段：初始化标记对象，并进行Minor GC ，此阶段会Stop The World Root Region Scanning：回收Survivor区，必须在Yong GC之前完成 Concurrent Marking：在整个堆中进行并发标记，此过程会被Yong GC打断，若发现区域存在垃圾对象则直接进行回收，此阶段会进行每个区域中存活对象的比例统计 Remark：再标记用来收集在并发阶段产生的垃圾对象，效率高于CMS，此阶段会Stop The World Copy/Clean up：多线程消除垃圾对象，将存活对象移动到新区域，此阶段会Stop The World After Copy/Clean G1 VS CMS G1 使用“标记-整理”算法，不会出现内存碎片，分配大对象不会因为找不到连续的空间进行GC 可预测停顿，G1能够建立可预测的停顿时间模型 GC组合使用 不同GC是可以进行组合使用的]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM内存回收]]></title>
    <url>%2F2018%2F04%2F05%2FJVM%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%2F</url>
    <content type="text"><![CDATA[在Java开发的过程中，程序的执行需要计算机内存空间，Java并没有语法与内存创建、释放有直接联系，JVM负责管理内存的申请与释放，对于Java语言来说，显示的内存申请通常有两种：静态内存分配与动态内存分配 静态内存的分配与回收 静态内存分配：Java类或方法中的原始类型数据和对象的引用都是静态分配的内存，当Java编译器执行编译后就已经确定了静态内存的大小，在程序被加载后会分配静态内存且在程序运行期间内存大小不会再改变 静态内存回收：程序执行结束后释放、方法执行结束后释放 动态内存的分配与回收 动态内存分配：Java中的对象类型的数据创建是动态的内存分配，只有在程序执行的过程中才知道程序所需的内存大小 动态内存分配：Java中的对象不再被使用的时候内存会被回收 垃圾回收 什么样的对象应该被认为是垃圾需要回收？对象是否是垃圾对象取决于对象的引用类型与对象是否根路径可达 如何回收垃圾对象释放内存？由垃圾回收算法负责 垃圾对象 对象与根节点之间的联系称为引用链，当对象与根节点之间不存在引用链时，此对象成为垃圾对象，根节点可以是以下元素 在方法中局部变量区的对象引用 在Java操作栈中的对象引用 在常量池中的对象引用（如常量池中引用的的类名String在堆中 在本地方法的对象引用 类的Class对象（JVM加载Class时，会在堆中创建一个代表这个类的唯一数据类型的Class对象 若对象被软引用，当内存不足时，软引用对象为垃圾对象 若对象被弱引用，则此对象为垃圾对象 若对象被虚引用，则此对象为垃圾对象 垃圾回收算法 垃圾搜集的算法主要有三种，分别是标记-清除算法、复制算法、标记-整理算法 标记清除算法 概述：在程序运行期间，若可以使用的内存耗尽，GC会暂停整个程序，随后将标记存活的对象，并将堆中没被标记的对象（根路径不可达的对象）清除，最后恢复程序 此算法缺点：标记清除算法的主要缺点是回收后的内存空间布局是分散的，JVM必须维护空闲的内存列表 复制算法 概述：复制算法将内存分为两个部分，内存只分配在其中的一个位置（活动区），另一个位置始终保持空闲（空闲区）。当有效内存耗尽，GC线程停止程序，复制算法开始。GC线程将活动区的存活对象移动到内存的空闲区（按顺序排列）并清除垃圾对象。适合存活率低的对象 此算法缺点：1.内存浪费。2.如果对象存活100% ，则对象将会整体移动！ 标记/整理算法 概述：标记/整理算法与标记/清除类似，只是在清除垃圾对象的同时将存活对象按地址进行了内存整理，JVM只需要维护内存的开始位置就可以方便支持后续的内存分配 此算法缺点：整理内存有更多的时间消耗 分代搜集算法 分代搜集算法是针对Java堆区的内存回收，是标记-清除算法、复制算法、标记-整理算法的综合实际运用 Young区垃圾回收：当Eden区满后会触发minor GC，minor GC 会利用复制算法进行此区的内存回收 Old区垃圾回收：当Old区满后会触发major GC or Full GC ， major GC or Full GC利用 标记/清除或标记/整理算法进行内存回收]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM内存管理]]></title>
    <url>%2F2018%2F04%2F04%2FJVM%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[记录 Java中的堆与栈究竟是什么，JVM在计算机物理内存中是如何工作的 计算机内存结构 计算机中存在不同类型的内存包括：RAM，CPU寄存器，缓存CACHE等 物理内存 物理内存一般指的是RAM与存储器，CPU与RAM或寄存器通信依靠的是地址总线。总线的宽度决定了CPU与内存间通信的数据量。如32位的地址总线寻址范围为：0x00000000~0xffffffff，即232个内存位置，每个内存位置会引用一个字节，所以232 byte = 4GB，计算机的内存是通过操作系统进行分配的，不同进程申请到的内存是逻辑上隔离的 虚拟内存 操作系统按照进程管理内存的申请，进程间各自内存由操作系统保证独立性，独立性不表示一个内存空间只能由一个进程使用。虚拟内存使得不同进程间可以共享内存空间，然而逻辑上不同进程是不能互相访问内存的。当一个进程不活动的情况下，操作系统会将这个进程中的数据移动到磁盘文件中（Windows中的页面文件或者Linux中的swap区），当不活跃进程恢复则操作系统会把磁盘数据重新交换到物理内存中（磁盘IO开销远大于读内存，应该避免频繁的内存交换），而真正高效的内存留给活跃进程使用。若Linux中的swap区活跃度较高说明物理内存的已经不足，swap区被频繁使用会导致系统运行缓慢。虚拟内存提高了内存利用率，而且能够扩展内存的地址空间，如虚拟内存映射到物理内存、文件、其他存储设备上 内核空间与用户空间 内核空间：只要是操作系统运行时使用的用于程序调度、连接硬件资源等的操作逻辑 用户空间：程序真正能够使用的申请地址空间 通常网络传输的数据一般从内核空间传送到远端计算机的内核空间，然后将数据从内核空间复制到用户空间供用户使用，这种数据COPY是很耗时的（内核态到用户态的切换 JMM内存模型 JMM是JVM针对物理内存抽象出来的Java内存模型，是JVM在计算机内存中的工作方式。JVM按照Java运行时数据的存储结构定义Java内存模型 PC寄存器 PC寄存器用来保存当前线程正常执行的程序的内存地址，当多线程交叉中断执行时线程能够按照之前中断时的指令继续执行 Java栈区 Java中的栈区与线程相关联，栈主要用来执行程序。JVM为每个新建线程创建栈区，栈区各线程不共享。栈区由多个栈帧组成，栈帧包含方法局部变量、操作栈、返回值等信息。每当程序进入方法都会创建一个栈帧（入栈，方法执行完毕后栈帧会弹出（出栈，弹出的栈帧元素为返回值存入操作栈中。PC寄存器指向活动栈帧（栈区顶部 堆 堆是Java对象存储的位置，由JVM动态开辟、自动回收，堆是Java运行时的数据区。堆是Java线程共享的区域，多线程访问存在一致性问题.堆区结构 堆的组成 Young区：Java新创建的对象都在Eden区，当Eden区满后会触发minor GC 将Eden区存活的对象复制到其中一个Survivor区，另一个Survivor区同样将存活对象复制到这个Survivor区，始终保证有一个Survivor区空置 Old区：Old区存储的是minor GC后 Yong区仍然存活的对象。当Eden区满后将对象复制到Survivor区。1.若Survivor空间不总则对象会被放置到Old区。2.若Survivor区中经过多次minor GC 存在 存活多次的“老”对象，也直接放置在Old区。Old区满后将触发Full GC Metaspace区：JDK1.8将Perm区移除取而代之为Metaspace区，Metaspace区为native memory 不同堆区大小设置1java -Xms100M -Xmx200M -Xmn100M -Xss256K -XX:MetaspaceSize=200M -XX:MaxMetaspaceSize=400M -Xms100M : 设置JVM初始堆内存大小 -Xmx200M : 设置JVM最大分配的堆内存 -Xmn100M : 设置Young区大小 -XX:NewRatio=4 : 设置Young区与Old区的比值，Young区：Old区 = 1:4 -XX:SurvivorRatio=4 : 设置Eden区与Survivor区的比值，From：To：Eden区 = 1:1:4 -XX:MetaspaceSize=200M : 设置Metaspace区初始大小 -XX:MaxMetaspaceSize=400M : 设置Metaspace区最大值（若未设置则JVM会动态调整，无上限 -Xss256K : 设置每个线程栈大小 方法区 Metaspace区是方法区的实现，主要存放类的结构信息、方法体、常量池、接口初始化，构造函数等，方法区的大小在程序启动一段时间基本就固定了，JVM已经加载了程序所需的类信息，若存在对类的动态编译则需要关注方法区的大小 运行常量池 常量池是方法区的一部分，常量池代表运行时每个class文件中的常量表，常量表包括：方法、域的引用（运行时会进行解析指向真实地址、编译期的数字常量。每个class或interface常量池都是在创建class或interface时创建的 本地方法栈 本地方法栈是 1.JVM调用本地方法（C或C++实现的方法）时的栈空间。2.JVM利用JIT技术时会将Java代码重新编译为本地代码，编译后的代码会利用本地方法栈追踪方法的执行 内存分配策略 静态内存分配：在程序编译阶段就已经确定每个数据在运行是的存储空间（java中的基本类型、对象引用，递归、嵌套结构会导致编译阶段无法确认程序运行存储空间大小 栈内存分配：程序对数据区的需求在编译时是未知的，只有运行时才能知道，但是在程序入口处 必须知道该程序所需的数据区大小 才能够为其分配内存，栈内存按照先进后出原则进行分配 堆内存分配：只有在程序真正运行到相应的代码时才知道空间的大小]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Char 编码]]></title>
    <url>%2F2018%2F03%2F31%2FJava-Char-%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[记录下自己对编码的理解和疑惑，什么是Unicode？UTF-8、UTF-16、ASCII又是什么？ 编码与解码 编码 ：信息从一种数据形式到另一种数据形式的转换过程。信息在计算机中的存储与传输是以二 进制的形式（010101）进行的，计算机中的存储单元为Byte，所以需要计算机处理的信息必须编码为Bytes。 解码：编码的逆向过程。计算机中为Bytes到字符信息的转换。 为什么要编码 计算机中的存储单元为Byte即8位的二进制形式，所能表达的字符范围为28 = 256种，现存的字符远远多于256种，所以单个字节不足以存够如此多的字符。不同字符的表达是多样性的，不同地区使用不同的语言表达（字符编码），不同的语言自然有不同的字典解释（字符解码）。如何解码呢？byte c1=97代表什么字符？int c2= 26790 又该如何翻译呢？ 解码翻译 ASCII、ISO-8859-1、GB2312、GBK、UTF-8、UTF-16编码表中记录了不同字符的不同表达方式。是否存在不同字符的统一表达方式呢？即所有字符存在同一张编码表中。Unicode编码集保存着全世界的字符的编码点（CodePoint)，可以存储足够多的字符表示。Unicode的编码形式又分为UTF-8，UTF-16，UTF-32分别表示8位，16位，32位存储。采用哪种编码需要在传输大小、编码效率等问题进行折中选择。UTF-8是可变长度的编码规则，一般会采用UTF-8进行编码， Unicode Unicode的编码点以U+开始如U+0x0020的形式表示，能表示的编码点范围为0x0000 ~ 0x10FFFF。我们知道Java中的字符都是以Unicode的形式保存的，并且采用UTF-16的形式编码，所以说Java中的char占用16位即2个字节，16位所能存储的最大值为0xFFFF。那么对于U+10000~U+10FFFF部分的CodePoint（这一部分代表的字符被称为辅助字符supplementary character），Java中的UTF-16显然无法存储 UTF-8的编码规则 编码点 编码方式 U+0000 ~ U+007F 0xxxxxxx U+0080 ~ U+07FF 110xxxxx 10xxxxxx U+0800 ~ U+FFFF 1110xxxx 10xxxxxx 10xxxxxx U+10000 ~ U+10FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx Java中的char类型 Java中的char类型采用UTF-16描述一个代码单元，对于超过0xFFFF的代码点的字符需要两个代码单元表示。刚好int类型(32位)可以存储所有的Unicode代码点。 简单事例12345678char bmp = &apos;\u68a6&apos;;System.out.println(&quot;BMP:&quot;+bmp);char[] chars = &#123;&apos;\uD800&apos;,&apos;\uDFC3&apos;&#125;;String supplementary = new String(chars);System.out.println(&quot;Supplementary:&quot;+supplementary);BMP:梦Supplementary:𐏃]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mary's Eyes]]></title>
    <url>%2F2018%2F03%2F31%2FMary's%20Eyes%2F</url>
    <content type="text"><![CDATA[我得承认男人有时蠢话连篇多亏有你处处留了颜面我有几次心不在焉将真话说得肤浅 –上上签–]]></content>
      <tags>
        <tag>M&amp;M</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker Swarm 集群]]></title>
    <url>%2F2018%2F03%2F30%2FDocker-Swarm-%E9%9B%86%E7%BE%A4%2F</url>
    <content type="text"><![CDATA[简单记录下Docker集群swarm使用。 Docker集群模式 docker swarm模式可以让多个运行docker的机器加入集群管理，加入集群的docker机器被称为node。整个集群被node为manager的角色管理，其他的node角色则为workers，所有workers接受manager的指令行事 Docker Swarm集群机器可以是物理机也可以是虚拟机，由于资源匮乏。本文只有一个 swarm node Manager Node：当发布service到swarm中（提交到管理节点），管理节点将service分发到Worker Node，工作节点接收到task开始工作 Worker Node：工作节点接受来自管理节点分发的任务并执行，同时会将自己当前的状态通知到管理节点，管理者能够管理集群中节点的状态。Manager Node同时也可以是Worker Node 开启swarm模式：docker swarm init 离开swarm：docker swarm leave --force Node工作方式 Services and tasks Services：任务的定义，创建service有两种模式。replicated services可以指定创建服务的副本数量由manager node分发到不同节点。global services模式的服务将在集群中所有节点上运行 tasks：任务是管理节点分发运行的单元 构建副本服务：docker service create --replicas 3 --name web nginx,service只有在swarm模式下才能创建 服务与任务的关系 replicated services和global services 集群网络docker swarm保证两种不同的通讯。管理通讯，如加入或是离开swarm 和 响应来自客户端的请求 Overlay networks： 管理swarm模式下docker daemons间的通信，service同样也可以加入此网络使service间能够相互通信。此网络使用overlay网络驱动 ingress network ： 此网络提供了服务的负载均衡能力。当客户端请求服务，ingress network中内建的负载均衡模块（IPVS）会将请求负载到指定的IP服务。此网络使用overlay网络驱动 docker_gwbridge： 此网络负责将Overlay networks和ingress network连通到docker daemon的物理网卡上，创建的service默认会连接到此网络。此网络使用bridge网络驱动 参考Docker v17.09]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker容器中的数据管理]]></title>
    <url>%2F2018%2F03%2F30%2FDocker%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[简单记录下Docker容器的数据管理 Docker镜像的存储 Docker镜像是一层一层叠出来的，Dockerfile中的每一行指令都会产生一层,镜像中的数据对容器是只读的 dockerfile中的命令可以直接访问底层（lower layer）已经产生的数据，当发生数据文件的修改时则会将底层文件复制到当前layer进行处理 docker history 镜像ID展示镜像组成结构 存储结构图 docker的storage driver负责处理每层数据处理与存储 Docker容器的存储 Docker容器在镜像的基础之上又叠了一层（Container layer即Thin R／W层，每个容器都会有自己的Thin R／W层，镜像可以共享） docker ps -s命令能够查看当前运行容器的大小 当Container layer层发生数据文件的修改时则会将底层文件复制到当前layer进行处理即docker中的copy-on-write (CoW)策略，不同于虚拟机的本质。 存储结构图 Container layer中的数据应该尽量的少，减少镜像大小，storage driver的引入同样会带来性能的下降并且在容器停止后数据将会消失。应该使用volumes（宿主机文件系统可持久化） DATA VOLUMES docker提供了三种类型的数据挂载：volume,bind mount,tmpfs mount，挂载的数据能够传递到容器内部，容器中的数据也会回传到挂在目录或文件中 Volumes Volumes是最理想的容器数据持久化选择。数据存储在宿主机中的/var/lib/docker/volumes/目录下，非docker进程不能够修改，由docker进行管理。好处如：DockerCLI 扩展，容器间共享数据更加安全等 volumes由volume driver的支持使容器能够加载远端的数据 volume使用：docker run -d -it --name devtest --mount source=devtest,target=/app nginx，devtest不存在会自动创建 Bind mount Bind mount挂载的文件或文件夹必须有存在的全路径 Bind mount多用于容器共享宿主机中的配置文件，如/etc/resolv.conf Bind mount使用：docker run -itd --name devtest --mount type=bind,source=/tmp,target=/app nginx,若app中已经存在数据，则tmp会掩盖app中的数据 tmpfs mount tmpfs挂载的数据被存在宿主机的内存中 当数据不需要持久化可以使用此挂载类型，如：系统启动使用的一次性数据 tmpfs mount使用： docker run -d -it --name tmptest --mount type=tmpfs,destination=/app nginx 删除未使用Docker对象 Images，Containers，Volumes和Networks这些docker对象不会被删除（除非指定删除），未被使用的docker对象仍然占据着磁盘空间，docker提供了相应的修剪方法 删除无用镜像 docker image prune #删除未打标签并且未被使用的镜像 docker image prune -a #删除所有未被容器使用的镜像 删除没有运行的容器 docker container prune 删除没有被容器引用的volume docker volume prune 参考Docker v17.09]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker容器间的通信]]></title>
    <url>%2F2018%2F03%2F30%2FDocker%E5%AE%B9%E5%99%A8%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[简单记录下容器间的网络通信。 网络驱动 network drivers是docker提供容器间网络通信的基础。docker默认提供了两中驱动：bridge和overlay docker network ls指令会列出当前存在的网络 docker在安装完成后会自动创建三个网络 BRIDGE 宿主机中使用ip addr show查看网卡状况 docker0为宿主机中的虚拟网桥即为docker自动创建的bridge网络 bridge为docker运行容器（docker run）默认使用的网络 容器与外部的网络通信前提 保证宿主机开启了ip_forward功能 保证iptables的相关策略的设置，如地址伪装,NAT等 宿主机与容器的端口映射 docker run -itd -P --name mongoService mongo，-P表示：容器暴露的端口将会映射到宿主机中的随机端口号，随机范围见：/proc/sys/net/ipv4/ip_local_port_range 每当启动容器与外部网络的通信，docker都会建立响应的iptables规则。iptables -L -n -t nat查看规则 容器间的网络通信 容器间可以通过IP或容器名进行网络通信 使用自己创建的NETWORK 创建my_bridge网络: docker network create -d bridge --subnet=10.0.0.0/24 my_bridge 运行使用my_bridge网络的容器 docker run -itd --network=my_bridge --ip=10.0.0.254 --name db busybox 不同NETWORK间的容器通信 docker run -itd --name=web busybox,使用默认的bridge network 将当前容器加入到需要与之通信的网络 docker network connect my_bridge web 网络结构 容器DNS 容器间如何通过别名进行网络通信？ 默认bridge网络 -- 创建测试容器 docker run -itd --name c1 busybox docker run -itd --name c2 busybox -- 进入容器c1内部 docker attach c1 / # ping c2 ping: bad address &apos;c2&apos; -- 创建容器时指定link容器 docker run -itd --link c2:c2_alias --name c3 busybox -- 进入容器c3内部 docker attach c3 / # ping -w1 c2 PING c2 (172.17.0.4): 56 data bytes 64 bytes from 172.17.0.4: seq=0 ttl=64 time=0.083 ms / # ping -w1 c2_alias PING c2_alias (172.17.0.4): 56 data bytes 64 bytes from 172.17.0.4: seq=0 ttl=64 time=0.096 ms / # cat /etc/hosts #（容器别名相互耦合） 127.0.0.1 localhost ::1 localhost ip6-localhost ip6-loopback fe00::0 ip6-localnet ff00::0 ip6-mcastprefix ff02::1 ip6-allnodes ff02::2 ip6-allrouters 172.17.0.4 c2_alias 7e4850ad6320 c2 #通信原因 172.17.0.6 fe51353cb1e3 -- 进入容器c2内部 docker attach c2 / # ping c3 ping: bad address &apos;c3&apos; 用户创建的bridge网络 -- 创建测试容器 docker run -itd --name c4 --net=my_bridge busybox docker run -itd --name c5 --net=my_bridge busybox -- 进入容器c4内部 docker attach c4 / # ping -w1 c5 #（自动创建DNS服务） PING c5 (10.0.0.3): 56 data bytes 64 bytes from 10.0.0.3: seq=0 ttl=64 time=0.066 ms 网络层可见别名 -- 创建测试容器 docker run -itd --name c7 --net=my_bridge --network-alias c7_net_alias busybox -- 进入容器c4内部 docker attach c4 / # ping -w1 c7_net_alias PING c7_net_alias (10.0.0.5): 56 data bytes 64 bytes from 10.0.0.5: seq=0 ttl=64 time=0.205 ms 参考Docker v17.09]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Dockerfile构建Docker镜像]]></title>
    <url>%2F2018%2F03%2F30%2F%E4%BD%BF%E7%94%A8Dockerfile%E6%9E%84%E5%BB%BADocker%E9%95%9C%E5%83%8F%2F</url>
    <content type="text"><![CDATA[简单记录下如何构建docker image Docker Build Usage dcoker build 命令将构建用到的内容发送给docker daemon,依次执行Dockerfile中的命令（每执行一行指令将会提交a new layer），执行成功image构建完成 构建docker image时，应该选择一个属于构建相关的目录（构建镜像所需内容），将会减少不必要的内容到docker daemon的传输从而加速构建 指定Dockerfile构建，docker build -t 8lovelife/activemq:1.0 -f /home/dmz/temp/Dockerfile . Dockerfile中相关指令RUN RUN用于在当前镜像之上a new layer执行所需命令，执行后结果将被提交并可被后续指令使用 SHELLFORM:RUN &lt;COMMAND&gt;,linux 中默认以/bin/sh -c 执行，windows默认为cmd /s /c EXECFORM:RUN [&quot;executable&quot;,&quot;param1&quot;,&quot;parma2&quot;],这种形式并不会执行命令shell。如RUN [&quot;echo&quot;,&quot;$DMZ&quot;]并不会输出解析后的变量DMZ，而RUN [&quot;sh&quot;,&quot;-c&quot;,&quot;echo $DMZ&quot;]可以解析变量DMZ（最终镜像中的系统变量） EXECFORM将以JSON Array形式解析，所以参数需要双引号且相关符号需要转译如反斜杠，如：RUN [&quot;C:\\windows\\system32&quot;] CMD CMD用于容器执行的默认行为(同样能够使容器以可执行的形式运行)，非必须存在。若在Dockerfile出现多次，只有最后一次会有效 CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] EXECFORM CMD [&quot;params1&quot;,&quot;param2&quot;] , 作为ENTRYPOINT的默认参数 CMD command param1 param2 SHELLFORM ENTRYPOINT ENTRYPOINT能够使容器以可执行的形式运行，只有最后出现的ENTRYPOINT才会有效。使用docker run --entrypoint可以指定覆盖 ENTRYPOINT [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] EXECFORM ENTRYPOINT command param1 param2 SHELLFORM,将不会使用CMD中的参数。这会成为/bin/sh -c的子命令，可执行命令不再是容器中的PID=1,这将导致容器无法无法接收Unix signals并且无法听从docker stop &lt;container&gt; SIGTERM，当stop 容器超时后，SIGKILL会被发出强制停止容器。使用 exec能够解决问题。 SHELL SHELL用于更改SHELLFORM中默认使用的shell，如windows使用powershell,SHELL [&quot;powershell&quot;, &quot;-command&quot;],多次SHELL指令将会覆盖之前的SHELL指令 CMD ／ ENTRYPOINT 构建activemq image Dockerfile： `FROM openjdk:8-jre-alpine` #Base Image OpenJDK8 `ENV ACTIVEMQ_VERSION 5.14.5` #环境变量 `ENV ACTIVEMQ apache-activemq-$ACTIVEMQ_VERSION` `ENV ACTIVEMQ_TCP=61616 ACTIVEMQ_AMQP=5672 ACTIVEMQ_STOMP=61613 ACTIVEMQ_MQTT=1883 ACTIVEMQ_WS=61614 ACTIVEMQ_UI=8161` `ENV ACTIVEMQ_HOME /opt/activemq` `RUN set -x &amp;&amp; \` #设置脚本执行跟踪 `mkdir -p /opt &amp;&amp; \ ` #建立目录/opt `apk --update add --virtual build-dependencies curl &amp;&amp; \` #添加curl命令到虚拟构建依赖组build-dependencies `curl -s -S https://archive.apache.org/dist/activemq/$ACTIVEMQ_VERSION/$ACTIVEMQ-bin.tar.gz | tar xvz -C /opt &amp;&amp; \` #下载activemq并解压到指定目录 `ln -s /opt/$ACTIVEMQ $ACTIVEMQ_HOME &amp;&amp; \` #建立软连接 `addgroup -S activemq &amp;&amp; adduser -S -H -G activemq -h $ACTIVEMQ_HOME activemq &amp;&amp; \` #添加用户&amp;用户组 `chown -R activemq:activemq /opt/$ACTIVEMQ &amp;&amp; \ chown -h activemq:activemq $ACTIVEMQ_HOME &amp;&amp; \ apk del build-dependencies &amp;&amp; \` #删除虚拟构建依赖组 `rm -rf /var/cache/apk/*` #删除install缓存，缩小image size ,反斜杠换行（同一条命令执行减少结果提交，减少image layer） `USER activemq` #用户切换（之后命令所属用户 `WORKDIR $ACTIVEMQ_HOME` `EXPOSE $ACTIVEMQ_TCP $ACTIVEMQ_AMQP $ACTIVEMQ_STOMP $ACTIVEMQ_MQTT $ACTIVEMQ_WS $ACTIVEMQ_UI` #暴露端口号 `CMD [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;bin/activemq console&quot;]` #容器启动后执行命令 构建docker build -t 8lovelife/activemq:1.0 . 参考Docker v17.6activemq Dockerfile来源]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker快速构建开发测试环境]]></title>
    <url>%2F2018%2F03%2F30%2FDocker%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BA%E5%BC%80%E5%8F%91%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[简单记录下我在开发过程中,如何快速构建调试环境 RedisService 下载Redis imagedocker pull redis 启动Redisdocker run --restart=always -d -ti --name redisService -v /home/core/redis/conf/redis.conf:/usr/local/etc/redis/redis.conf -v /home/core/redis/data:/data -p 16379:6379 redis redis-server /usr/local/etc/redis/redis.conf 登录Redisdocker exec -it redisService redis-cli --raw -a redis MysqlService 下载Mysql imagedocker pull mysql 启动Mysqldocker run --restart=always -it --name mysqlService -v /home/core/mysql/data/:/var/lib/mysql -v /home/core/mysql/conf.d:/etc/mysql/conf.d -p 13306:3306 -e MYSQL\_ROOT\_PASSWORD=12345 -d mysql MongoService 下载Mongo imagedocker pull mongo 启动MongoDBdocker run -ti --restart=always --name mongoService -v /home/core/mongo/data:/data/db -p 27017:27017 -d mongo --auth 登录Mongo,建立用户1.docker exec -it mongoService mongo admin;2.db.createUser({user:&#39;admin&#39;,pwd:&#39;admin&#39;,roles:[{role:&#39;root&#39;,db:&#39;admin&#39;}]});3.db.auth(&#39;admin&#39;,&#39;admin&#39;); 创建collection dmz_inward下的普通用户:use dmz_inward; db.createUser({user:&#39;dmz&#39;,pwd:&#39;dmz&#39;,roles: [{role:&#39;readWrite&#39;,db:&#39;dmz_inward&#39;}]}); NginxService 下载Nginx imagedocker pull nginx 启动Nginxdocker run -it --restart=always --name nginxService -p 80:80 -v /home/core/yourResources: /usr/share/nginx/html:ro -v /logs:/var/log/nginx -v /home/core/conf/nginx/nginx.conf:ro -d nginx RabbitmqService 下载rabbitmq:3-managementdocker pull rabbitmq:3-management 启动rabbitmq:3-managementdocker run --restart=always --name rabbitmqService--hostname fRabbit-p 5672:5672 -p 15672:15672-v /home/core/rabbitmq/data:/var/lib/rabbitmq/mnesia/rabbit@fRabbit-v /home/core/rabbitmq/conf/rabbitmq.config:/etc/rabbitmq/rabbitmq.config:ro-d rabbitmq:3-management rabbitmq.config配置[ { rabbit, [ `{ loopback_users, [ ] },` ` { tcp_listeners, [ 5672 ] },` `{ default_user, &lt;&lt;&quot;dmz&quot;&gt;&gt; },` #用户名 ` { default_pass, &lt;&lt;&quot;dmz&quot;&gt;&gt; },` #密码 ` { ssl_listeners, [ ] },` `{ hipe_compile, false }` ] },{rabbitmq_management, [{listener, [{port, 15672}]}]} ]. 访问rabbitmq管理界面http://ip:15672 Portainer漂亮的docker容器管理界面 下载portainer imagedocker pull portainer/portainer 启动Portainerdocker run -d --restart=always --name=portainer -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock portainer/portainer 访问http://ip:9000 name:name pwd:pwd KafkaKafka 参考Docker Hub]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker Plugin]]></title>
    <url>%2F2018%2F03%2F30%2FDocker-Plugin%2F</url>
    <content type="text"><![CDATA[简单记录下我在IntelliJ IDEA中如何使用Docker Intellij Idea 配置Docker Docker ：Docker是目前比较流行的容器，帮你管理应用服务 —— Docker官网 下载Docker插件 启动Docker Daemon 启用TCP连接：sudo docker daemon -H tcp://0.0.0.0:4243 -H unix:///var/run/docker.sock Certificates 将Docker登录证书拷贝到本地，准备连接 连接Docker Intellij Idea 15.0Intellij Idea 2016 配置Docker Registry Deploy on DockerRun/Debug Configurations 构建Docker镜像 Dockerfile（build image）Dockerfile:FROM tomcatADD HelloWorld.war /usr/local/tomcat/webapps Docker容器参数配置Container.json:{ “HostConfig”: { “PortBindings”:{ “8080/tcp”: [{ “HostIp”: “0.0.0.0”, “HostPort”: “18080” }] } }} 发布镜像 加载容器配置JSON file Start Dockerlocalhost:18080/HelloWorld 参考DockerIntelliJ IDEA]]></content>
      <tags>
        <tag>Docker</tag>
        <tag>IntelliJ IDEA</tag>
      </tags>
  </entry>
</search>
